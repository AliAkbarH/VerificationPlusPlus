/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : scma.g
 *     -                            On : 2020-05-03 05:22:50
 *     -                for the parser : scmaParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "scmaParser.h"
/* ----------------------------------------- */

/** \file   scma.g
*   \brief  grammar for the specification construction input
*   \author fadi zaraket 
*   \date   march 26, 2013
*/




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pscmaParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pscmaParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pscmaParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pscmaParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		ISTREAM							INPUT->istream
#define		INDEX()							ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   scmaParserTokenNames[46+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "DECIMAL_LITERAL",
        (pANTLR3_UINT8) "RELATIONAL_OP",
        (pANTLR3_UINT8) "BOOLEAN_OP",
        (pANTLR3_UINT8) "ADDITION_OP",
        (pANTLR3_UINT8) "PRODUCT_OP",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "LETTER",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "LINE_COMMENT",
        (pANTLR3_UINT8) "'theory'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'constants'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'}'",
        (pANTLR3_UINT8) "'grammar'",
        (pANTLR3_UINT8) "'num_operations_per_clause_bound'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'num_quantifiers_bound'",
        (pANTLR3_UINT8) "'vocab'",
        (pANTLR3_UINT8) "'const'",
        (pANTLR3_UINT8) "'universal'",
        (pANTLR3_UINT8) "'global'",
        (pANTLR3_UINT8) "'existential'",
        (pANTLR3_UINT8) "'local'",
        (pANTLR3_UINT8) "'int'",
        (pANTLR3_UINT8) "'[]'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'boolean'",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'true'",
        (pANTLR3_UINT8) "'false'",
        (pANTLR3_UINT8) "'!'",
        (pANTLR3_UINT8) "'not'",
        (pANTLR3_UINT8) "'forall'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'exists'",
        (pANTLR3_UINT8) "'bound'",
        (pANTLR3_UINT8) "'index'",
        (pANTLR3_UINT8) "'arithmetic'",
        (pANTLR3_UINT8) "'relational'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static SCTheory *	translation_unit    (pscmaParser ctx);
static unsigned int	declaration    (pscmaParser ctx);
static scmaParser_declaration_specifier_return	declaration_specifier    (pscmaParser ctx);
static unsigned int	type_modifier    (pscmaParser ctx);
static scstring	declarator    (pscmaParser ctx);
static scmaParser_type_specifier_return	type_specifier    (pscmaParser ctx);
static scstring	direct_declarator    (pscmaParser ctx);
static int	constant    (pscmaParser ctx);
static void	grammar_rule    (pscmaParser ctx);
static int	clause    (pscmaParser ctx);
static int	boolean_expression    (pscmaParser ctx);
static int	term    (pscmaParser ctx);
static int	additionop    (pscmaParser ctx);
static int	productop    (pscmaParser ctx);
static int	unaryop    (pscmaParser ctx);
static int	atom    (pscmaParser ctx);
static scmaParser_operation_return	operation    (pscmaParser ctx);
static ANTLR3_BOOLEAN	synpred18_scma    (pscmaParser ctx);
static ANTLR3_BOOLEAN	synpred21_scma    (pscmaParser ctx);
static ANTLR3_BOOLEAN	synpred22_scma    (pscmaParser ctx);
static ANTLR3_BOOLEAN	synpred26_scma    (pscmaParser ctx);
static ANTLR3_BOOLEAN	synpred31_scma    (pscmaParser ctx);
static ANTLR3_BOOLEAN	synpred32_scma    (pscmaParser ctx);
static void	scmaParserFree(pscmaParser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "scma.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new scmaParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pscmaParser
scmaParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return scmaParserNewSSD(instream, NULL);
}

/** \brief Create a new scmaParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pscmaParser
scmaParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pscmaParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pscmaParser) ANTLR3_CALLOC(1, sizeof(scmaParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in scmaParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our scmaParser interface
     */
    ctx->translation_unit	= translation_unit;
    ctx->declaration	= declaration;
    ctx->declaration_specifier	= declaration_specifier;
    ctx->type_modifier	= type_modifier;
    ctx->declarator	= declarator;
    ctx->type_specifier	= type_specifier;
    ctx->direct_declarator	= direct_declarator;
    ctx->constant	= constant;
    ctx->grammar_rule	= grammar_rule;
    ctx->clause	= clause;
    ctx->boolean_expression	= boolean_expression;
    ctx->term	= term;
    ctx->additionop	= additionop;
    ctx->productop	= productop;
    ctx->unaryop	= unaryop;
    ctx->atom	= atom;
    ctx->operation	= operation;
    ctx->synpred18_scma	= synpred18_scma;
    ctx->synpred21_scma	= synpred21_scma;
    ctx->synpred22_scma	= synpred22_scma;
    ctx->synpred26_scma	= synpred26_scma;
    ctx->synpred31_scma	= synpred31_scma;
    ctx->synpred32_scma	= synpred32_scma;
    ctx->free			= scmaParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

    /* Create a LIST for recording rule memos.
     */
     RULEMEMO    = antlr3IntTrieNew(15);	/* 16 bit depth is enough for 32768 rules! */
	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = scmaParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 scmaParserFree(pscmaParser ctx)
 {
    /* Free any scope memory
     */
    
        
	if	(RULEMEMO != NULL)
	{
		RULEMEMO->free(RULEMEMO);
		RULEMEMO = NULL;
	}	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return scmaParserTokenNames; 
}


      SCTheory * theory=0;
      int success = 1;

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_translation_unit122  */
static	ANTLR3_BITWORD FOLLOW_15_in_translation_unit122_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_15_in_translation_unit122	= { FOLLOW_15_in_translation_unit122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_translation_unit127  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_translation_unit127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_translation_unit127	= { FOLLOW_IDENTIFIER_in_translation_unit127_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_16_in_translation_unit141  */
static	ANTLR3_BITWORD FOLLOW_16_in_translation_unit141_bits[]	= { ANTLR3_UINT64_LIT(0x00000008FC000000) };
static  ANTLR3_BITSET_LIST FOLLOW_16_in_translation_unit141	= { FOLLOW_16_in_translation_unit141_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_in_translation_unit146  */
static	ANTLR3_BITWORD FOLLOW_declaration_in_translation_unit146_bits[]	= { ANTLR3_UINT64_LIT(0x00000008FF3A0000) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_in_translation_unit146	= { FOLLOW_declaration_in_translation_unit146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_17_in_translation_unit165  */
static	ANTLR3_BITWORD FOLLOW_17_in_translation_unit165_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_17_in_translation_unit165	= { FOLLOW_17_in_translation_unit165_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_16_in_translation_unit167  */
static	ANTLR3_BITWORD FOLLOW_16_in_translation_unit167_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_16_in_translation_unit167	= { FOLLOW_16_in_translation_unit167_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_translation_unit171  */
static	ANTLR3_BITWORD FOLLOW_constant_in_translation_unit171_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_translation_unit171	= { FOLLOW_constant_in_translation_unit171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_translation_unit185  */
static	ANTLR3_BITWORD FOLLOW_18_in_translation_unit185_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_translation_unit185	= { FOLLOW_18_in_translation_unit185_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_translation_unit189  */
static	ANTLR3_BITWORD FOLLOW_constant_in_translation_unit189_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_translation_unit189	= { FOLLOW_constant_in_translation_unit189_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_translation_unit204  */
static	ANTLR3_BITWORD FOLLOW_19_in_translation_unit204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003380000) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_translation_unit204	= { FOLLOW_19_in_translation_unit204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_20_in_translation_unit211  */
static	ANTLR3_BITWORD FOLLOW_20_in_translation_unit211_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_20_in_translation_unit211	= { FOLLOW_20_in_translation_unit211_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_16_in_translation_unit213  */
static	ANTLR3_BITWORD FOLLOW_16_in_translation_unit213_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_16_in_translation_unit213	= { FOLLOW_16_in_translation_unit213_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_grammar_rule_in_translation_unit218  */
static	ANTLR3_BITWORD FOLLOW_grammar_rule_in_translation_unit218_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_grammar_rule_in_translation_unit218	= { FOLLOW_grammar_rule_in_translation_unit218_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_translation_unit233  */
static	ANTLR3_BITWORD FOLLOW_19_in_translation_unit233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003280000) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_translation_unit233	= { FOLLOW_19_in_translation_unit233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_21_in_translation_unit239  */
static	ANTLR3_BITWORD FOLLOW_21_in_translation_unit239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_21_in_translation_unit239	= { FOLLOW_21_in_translation_unit239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_translation_unit241  */
static	ANTLR3_BITWORD FOLLOW_22_in_translation_unit241_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_translation_unit241	= { FOLLOW_22_in_translation_unit241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_translation_unit245  */
static	ANTLR3_BITWORD FOLLOW_constant_in_translation_unit245_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_translation_unit245	= { FOLLOW_constant_in_translation_unit245_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_translation_unit258  */
static	ANTLR3_BITWORD FOLLOW_23_in_translation_unit258_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003080000) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_translation_unit258	= { FOLLOW_23_in_translation_unit258_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_24_in_translation_unit264  */
static	ANTLR3_BITWORD FOLLOW_24_in_translation_unit264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_24_in_translation_unit264	= { FOLLOW_24_in_translation_unit264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_translation_unit266  */
static	ANTLR3_BITWORD FOLLOW_22_in_translation_unit266_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_translation_unit266	= { FOLLOW_22_in_translation_unit266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_translation_unit270  */
static	ANTLR3_BITWORD FOLLOW_constant_in_translation_unit270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_translation_unit270	= { FOLLOW_constant_in_translation_unit270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_translation_unit283  */
static	ANTLR3_BITWORD FOLLOW_23_in_translation_unit283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002080000) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_translation_unit283	= { FOLLOW_23_in_translation_unit283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_translation_unit290  */
static	ANTLR3_BITWORD FOLLOW_25_in_translation_unit290_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_translation_unit290	= { FOLLOW_25_in_translation_unit290_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_16_in_translation_unit292  */
static	ANTLR3_BITWORD FOLLOW_16_in_translation_unit292_bits[]	= { ANTLR3_UINT64_LIT(0x000001A000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_16_in_translation_unit292	= { FOLLOW_16_in_translation_unit292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_clause_in_translation_unit297  */
static	ANTLR3_BITWORD FOLLOW_clause_in_translation_unit297_bits[]	= { ANTLR3_UINT64_LIT(0x000001A000080010) };
static  ANTLR3_BITSET_LIST FOLLOW_clause_in_translation_unit297	= { FOLLOW_clause_in_translation_unit297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_translation_unit312  */
static	ANTLR3_BITWORD FOLLOW_19_in_translation_unit312_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_translation_unit312	= { FOLLOW_19_in_translation_unit312_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_translation_unit316  */
static	ANTLR3_BITWORD FOLLOW_19_in_translation_unit316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_translation_unit316	= { FOLLOW_19_in_translation_unit316_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_specifier_in_declaration352  */
static	ANTLR3_BITWORD FOLLOW_declaration_specifier_in_declaration352_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_specifier_in_declaration352	= { FOLLOW_declaration_specifier_in_declaration352_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarator_in_declaration356  */
static	ANTLR3_BITWORD FOLLOW_declarator_in_declaration356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000C00000) };
static  ANTLR3_BITSET_LIST FOLLOW_declarator_in_declaration356	= { FOLLOW_declarator_in_declaration356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_declaration359  */
static	ANTLR3_BITWORD FOLLOW_22_in_declaration359_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_declaration359	= { FOLLOW_22_in_declaration359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_declaration363  */
static	ANTLR3_BITWORD FOLLOW_constant_in_declaration363_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_declaration363	= { FOLLOW_constant_in_declaration363_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_declaration378  */
static	ANTLR3_BITWORD FOLLOW_23_in_declaration378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_declaration378	= { FOLLOW_23_in_declaration378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_modifier_in_declaration_specifier409  */
static	ANTLR3_BITWORD FOLLOW_type_modifier_in_declaration_specifier409_bits[]	= { ANTLR3_UINT64_LIT(0x00000008FC000000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_modifier_in_declaration_specifier409	= { FOLLOW_type_modifier_in_declaration_specifier409_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_specifier_in_declaration_specifier421  */
static	ANTLR3_BITWORD FOLLOW_type_specifier_in_declaration_specifier421_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_specifier_in_declaration_specifier421	= { FOLLOW_type_specifier_in_declaration_specifier421_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_26_in_type_modifier454  */
static	ANTLR3_BITWORD FOLLOW_26_in_type_modifier454_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_26_in_type_modifier454	= { FOLLOW_26_in_type_modifier454_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_type_modifier461  */
static	ANTLR3_BITWORD FOLLOW_27_in_type_modifier461_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_type_modifier461	= { FOLLOW_27_in_type_modifier461_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_type_modifier467  */
static	ANTLR3_BITWORD FOLLOW_28_in_type_modifier467_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_type_modifier467	= { FOLLOW_28_in_type_modifier467_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_type_modifier473  */
static	ANTLR3_BITWORD FOLLOW_29_in_type_modifier473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_type_modifier473	= { FOLLOW_29_in_type_modifier473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_type_modifier480  */
static	ANTLR3_BITWORD FOLLOW_30_in_type_modifier480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_type_modifier480	= { FOLLOW_30_in_type_modifier480_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_direct_declarator_in_declarator503  */
static	ANTLR3_BITWORD FOLLOW_direct_declarator_in_declarator503_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_direct_declarator_in_declarator503	= { FOLLOW_direct_declarator_in_declarator503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_type_specifier540  */
static	ANTLR3_BITWORD FOLLOW_31_in_type_specifier540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_type_specifier540	= { FOLLOW_31_in_type_specifier540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_type_specifier555  */
static	ANTLR3_BITWORD FOLLOW_31_in_type_specifier555_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_type_specifier555	= { FOLLOW_31_in_type_specifier555_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_type_specifier557  */
static	ANTLR3_BITWORD FOLLOW_32_in_type_specifier557_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_type_specifier557	= { FOLLOW_32_in_type_specifier557_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_type_specifier572  */
static	ANTLR3_BITWORD FOLLOW_31_in_type_specifier572_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_type_specifier572	= { FOLLOW_31_in_type_specifier572_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_type_specifier574  */
static	ANTLR3_BITWORD FOLLOW_33_in_type_specifier574_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_type_specifier574	= { FOLLOW_33_in_type_specifier574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_type_specifier578  */
static	ANTLR3_BITWORD FOLLOW_constant_in_type_specifier578_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_type_specifier578	= { FOLLOW_constant_in_type_specifier578_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_type_specifier582  */
static	ANTLR3_BITWORD FOLLOW_34_in_type_specifier582_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_type_specifier582	= { FOLLOW_34_in_type_specifier582_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_type_specifier597  */
static	ANTLR3_BITWORD FOLLOW_35_in_type_specifier597_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_type_specifier597	= { FOLLOW_35_in_type_specifier597_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_type_specifier612  */
static	ANTLR3_BITWORD FOLLOW_35_in_type_specifier612_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_type_specifier612	= { FOLLOW_35_in_type_specifier612_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_type_specifier614  */
static	ANTLR3_BITWORD FOLLOW_33_in_type_specifier614_bits[]	= { ANTLR3_UINT64_LIT(0x0000001400000020) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_type_specifier614	= { FOLLOW_33_in_type_specifier614_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_type_specifier619  */
static	ANTLR3_BITWORD FOLLOW_constant_in_type_specifier619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_type_specifier619	= { FOLLOW_constant_in_type_specifier619_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_type_specifier625  */
static	ANTLR3_BITWORD FOLLOW_34_in_type_specifier625_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_type_specifier625	= { FOLLOW_34_in_type_specifier625_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_type_specifier640  */
static	ANTLR3_BITWORD FOLLOW_31_in_type_specifier640_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_type_specifier640	= { FOLLOW_31_in_type_specifier640_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_type_specifier643  */
static	ANTLR3_BITWORD FOLLOW_33_in_type_specifier643_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_type_specifier643	= { FOLLOW_33_in_type_specifier643_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_type_specifier647  */
static	ANTLR3_BITWORD FOLLOW_constant_in_type_specifier647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_type_specifier647	= { FOLLOW_constant_in_type_specifier647_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_type_specifier649  */
static	ANTLR3_BITWORD FOLLOW_34_in_type_specifier649_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_type_specifier649	= { FOLLOW_34_in_type_specifier649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_type_specifier651  */
static	ANTLR3_BITWORD FOLLOW_33_in_type_specifier651_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_type_specifier651	= { FOLLOW_33_in_type_specifier651_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_type_specifier655  */
static	ANTLR3_BITWORD FOLLOW_constant_in_type_specifier655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_type_specifier655	= { FOLLOW_constant_in_type_specifier655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_type_specifier657  */
static	ANTLR3_BITWORD FOLLOW_34_in_type_specifier657_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_type_specifier657	= { FOLLOW_34_in_type_specifier657_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_type_specifier669  */
static	ANTLR3_BITWORD FOLLOW_35_in_type_specifier669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_type_specifier669	= { FOLLOW_35_in_type_specifier669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_type_specifier671  */
static	ANTLR3_BITWORD FOLLOW_33_in_type_specifier671_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_type_specifier671	= { FOLLOW_33_in_type_specifier671_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_type_specifier675  */
static	ANTLR3_BITWORD FOLLOW_constant_in_type_specifier675_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_type_specifier675	= { FOLLOW_constant_in_type_specifier675_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_type_specifier677  */
static	ANTLR3_BITWORD FOLLOW_34_in_type_specifier677_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_type_specifier677	= { FOLLOW_34_in_type_specifier677_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_type_specifier679  */
static	ANTLR3_BITWORD FOLLOW_33_in_type_specifier679_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_type_specifier679	= { FOLLOW_33_in_type_specifier679_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_type_specifier683  */
static	ANTLR3_BITWORD FOLLOW_constant_in_type_specifier683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_type_specifier683	= { FOLLOW_constant_in_type_specifier683_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_type_specifier685  */
static	ANTLR3_BITWORD FOLLOW_34_in_type_specifier685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_type_specifier685	= { FOLLOW_34_in_type_specifier685_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_direct_declarator717  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_direct_declarator717_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_direct_declarator717	= { FOLLOW_IDENTIFIER_in_direct_declarator717_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_constant755  */
static	ANTLR3_BITWORD FOLLOW_36_in_constant755_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_constant755	= { FOLLOW_36_in_constant755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECIMAL_LITERAL_in_constant772  */
static	ANTLR3_BITWORD FOLLOW_DECIMAL_LITERAL_in_constant772_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DECIMAL_LITERAL_in_constant772	= { FOLLOW_DECIMAL_LITERAL_in_constant772_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_grammar_rule803  */
static	ANTLR3_BITWORD FOLLOW_37_in_grammar_rule803_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_grammar_rule803	= { FOLLOW_37_in_grammar_rule803_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_grammar_rule807  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_grammar_rule807_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_grammar_rule807	= { FOLLOW_IDENTIFIER_in_grammar_rule807_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_grammar_rule819  */
static	ANTLR3_BITWORD FOLLOW_18_in_grammar_rule819_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_grammar_rule819	= { FOLLOW_18_in_grammar_rule819_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_grammar_rule824  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_grammar_rule824_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_grammar_rule824	= { FOLLOW_IDENTIFIER_in_grammar_rule824_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_grammar_rule839  */
static	ANTLR3_BITWORD FOLLOW_constant_in_grammar_rule839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_grammar_rule839	= { FOLLOW_constant_in_grammar_rule839_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_grammar_rule851  */
static	ANTLR3_BITWORD FOLLOW_18_in_grammar_rule851_bits[]	= { ANTLR3_UINT64_LIT(0x0003C00100400340) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_grammar_rule851	= { FOLLOW_18_in_grammar_rule851_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_operation_in_grammar_rule855  */
static	ANTLR3_BITWORD FOLLOW_operation_in_grammar_rule855_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_operation_in_grammar_rule855	= { FOLLOW_operation_in_grammar_rule855_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_grammar_rule866  */
static	ANTLR3_BITWORD FOLLOW_18_in_grammar_rule866_bits[]	= { ANTLR3_UINT64_LIT(0x0003C00100400340) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_grammar_rule866	= { FOLLOW_18_in_grammar_rule866_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_operation_in_grammar_rule870  */
static	ANTLR3_BITWORD FOLLOW_operation_in_grammar_rule870_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_operation_in_grammar_rule870	= { FOLLOW_operation_in_grammar_rule870_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_grammar_rule884  */
static	ANTLR3_BITWORD FOLLOW_38_in_grammar_rule884_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_grammar_rule884	= { FOLLOW_38_in_grammar_rule884_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_grammar_rule894  */
static	ANTLR3_BITWORD FOLLOW_23_in_grammar_rule894_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_grammar_rule894	= { FOLLOW_23_in_grammar_rule894_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_clause912  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_clause912_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_clause912	= { FOLLOW_boolean_expression_in_clause912_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_clause921  */
static	ANTLR3_BITWORD FOLLOW_23_in_clause921_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_clause921	= { FOLLOW_23_in_clause921_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_clause929  */
static	ANTLR3_BITWORD FOLLOW_37_in_clause929_bits[]	= { ANTLR3_UINT64_LIT(0x000001A000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_clause929	= { FOLLOW_37_in_clause929_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_clause933  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_clause933_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_clause933	= { FOLLOW_boolean_expression_in_clause933_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_clause935  */
static	ANTLR3_BITWORD FOLLOW_38_in_clause935_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_clause935	= { FOLLOW_38_in_clause935_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_clause943  */
static	ANTLR3_BITWORD FOLLOW_23_in_clause943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_clause943	= { FOLLOW_23_in_clause943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_boolean_expression963  */
static	ANTLR3_BITWORD FOLLOW_39_in_boolean_expression963_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_boolean_expression963	= { FOLLOW_39_in_boolean_expression963_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_boolean_expression980  */
static	ANTLR3_BITWORD FOLLOW_40_in_boolean_expression980_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_boolean_expression980	= { FOLLOW_40_in_boolean_expression980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_boolean_expression998  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_boolean_expression998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_boolean_expression998	= { FOLLOW_IDENTIFIER_in_boolean_expression998_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_boolean_expression1014  */
static	ANTLR3_BITWORD FOLLOW_37_in_boolean_expression1014_bits[]	= { ANTLR3_UINT64_LIT(0x0000003000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_boolean_expression1014	= { FOLLOW_37_in_boolean_expression1014_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_boolean_expression1018  */
static	ANTLR3_BITWORD FOLLOW_term_in_boolean_expression1018_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400040) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_boolean_expression1018	= { FOLLOW_term_in_boolean_expression1018_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RELATIONAL_OP_in_boolean_expression1023  */
static	ANTLR3_BITWORD FOLLOW_RELATIONAL_OP_in_boolean_expression1023_bits[]	= { ANTLR3_UINT64_LIT(0x0000003000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_RELATIONAL_OP_in_boolean_expression1023	= { FOLLOW_RELATIONAL_OP_in_boolean_expression1023_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_boolean_expression1045  */
static	ANTLR3_BITWORD FOLLOW_22_in_boolean_expression1045_bits[]	= { ANTLR3_UINT64_LIT(0x0000003000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_boolean_expression1045	= { FOLLOW_22_in_boolean_expression1045_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_boolean_expression1069  */
static	ANTLR3_BITWORD FOLLOW_term_in_boolean_expression1069_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_boolean_expression1069	= { FOLLOW_term_in_boolean_expression1069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_boolean_expression1071  */
static	ANTLR3_BITWORD FOLLOW_38_in_boolean_expression1071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_boolean_expression1071	= { FOLLOW_38_in_boolean_expression1071_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_boolean_expression1086  */
static	ANTLR3_BITWORD FOLLOW_37_in_boolean_expression1086_bits[]	= { ANTLR3_UINT64_LIT(0x000001A000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_boolean_expression1086	= { FOLLOW_37_in_boolean_expression1086_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_boolean_expression1090  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_boolean_expression1090_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_boolean_expression1090	= { FOLLOW_boolean_expression_in_boolean_expression1090_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BOOLEAN_OP_in_boolean_expression1094  */
static	ANTLR3_BITWORD FOLLOW_BOOLEAN_OP_in_boolean_expression1094_bits[]	= { ANTLR3_UINT64_LIT(0x000001A000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_BOOLEAN_OP_in_boolean_expression1094	= { FOLLOW_BOOLEAN_OP_in_boolean_expression1094_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_boolean_expression1098  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_boolean_expression1098_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_boolean_expression1098	= { FOLLOW_boolean_expression_in_boolean_expression1098_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_boolean_expression1100  */
static	ANTLR3_BITWORD FOLLOW_38_in_boolean_expression1100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_boolean_expression1100	= { FOLLOW_38_in_boolean_expression1100_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_boolean_expression1116  */
static	ANTLR3_BITWORD FOLLOW_37_in_boolean_expression1116_bits[]	= { ANTLR3_UINT64_LIT(0x0000060000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_boolean_expression1116	= { FOLLOW_37_in_boolean_expression1116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_boolean_expression1118  */
static	ANTLR3_BITWORD FOLLOW_set_in_boolean_expression1118_bits[]	= { ANTLR3_UINT64_LIT(0x000001A000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_boolean_expression1118	= { FOLLOW_set_in_boolean_expression1118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_boolean_expression1126  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_boolean_expression1126_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_boolean_expression1126	= { FOLLOW_boolean_expression_in_boolean_expression1126_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_boolean_expression1128  */
static	ANTLR3_BITWORD FOLLOW_38_in_boolean_expression1128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_boolean_expression1128	= { FOLLOW_38_in_boolean_expression1128_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_boolean_expression1144  */
static	ANTLR3_BITWORD FOLLOW_37_in_boolean_expression1144_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_boolean_expression1144	= { FOLLOW_37_in_boolean_expression1144_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_boolean_expression1146  */
static	ANTLR3_BITWORD FOLLOW_43_in_boolean_expression1146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_boolean_expression1146	= { FOLLOW_43_in_boolean_expression1146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_boolean_expression1150  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_boolean_expression1150_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_boolean_expression1150	= { FOLLOW_IDENTIFIER_in_boolean_expression1150_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_boolean_expression1152  */
static	ANTLR3_BITWORD FOLLOW_44_in_boolean_expression1152_bits[]	= { ANTLR3_UINT64_LIT(0x000001A000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_boolean_expression1152	= { FOLLOW_44_in_boolean_expression1152_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_boolean_expression1156  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_boolean_expression1156_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_boolean_expression1156	= { FOLLOW_boolean_expression_in_boolean_expression1156_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_boolean_expression1158  */
static	ANTLR3_BITWORD FOLLOW_38_in_boolean_expression1158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_boolean_expression1158	= { FOLLOW_38_in_boolean_expression1158_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_boolean_expression1173  */
static	ANTLR3_BITWORD FOLLOW_37_in_boolean_expression1173_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_boolean_expression1173	= { FOLLOW_37_in_boolean_expression1173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_45_in_boolean_expression1175  */
static	ANTLR3_BITWORD FOLLOW_45_in_boolean_expression1175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_45_in_boolean_expression1175	= { FOLLOW_45_in_boolean_expression1175_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_boolean_expression1179  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_boolean_expression1179_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_boolean_expression1179	= { FOLLOW_IDENTIFIER_in_boolean_expression1179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_boolean_expression1181  */
static	ANTLR3_BITWORD FOLLOW_44_in_boolean_expression1181_bits[]	= { ANTLR3_UINT64_LIT(0x000001A000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_boolean_expression1181	= { FOLLOW_44_in_boolean_expression1181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_boolean_expression1185  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_boolean_expression1185_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_boolean_expression1185	= { FOLLOW_boolean_expression_in_boolean_expression1185_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_boolean_expression1187  */
static	ANTLR3_BITWORD FOLLOW_38_in_boolean_expression1187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_boolean_expression1187	= { FOLLOW_38_in_boolean_expression1187_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_additionop_in_term1214  */
static	ANTLR3_BITWORD FOLLOW_additionop_in_term1214_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_additionop_in_term1214	= { FOLLOW_additionop_in_term1214_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_productop_in_additionop1237  */
static	ANTLR3_BITWORD FOLLOW_productop_in_additionop1237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_productop_in_additionop1237	= { FOLLOW_productop_in_additionop1237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ADDITION_OP_in_additionop1253  */
static	ANTLR3_BITWORD FOLLOW_ADDITION_OP_in_additionop1253_bits[]	= { ANTLR3_UINT64_LIT(0x0000003000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_ADDITION_OP_in_additionop1253	= { FOLLOW_ADDITION_OP_in_additionop1253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_productop_in_additionop1257  */
static	ANTLR3_BITWORD FOLLOW_productop_in_additionop1257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_productop_in_additionop1257	= { FOLLOW_productop_in_additionop1257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryop_in_productop1301  */
static	ANTLR3_BITWORD FOLLOW_unaryop_in_productop1301_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryop_in_productop1301	= { FOLLOW_unaryop_in_productop1301_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PRODUCT_OP_in_productop1317  */
static	ANTLR3_BITWORD FOLLOW_PRODUCT_OP_in_productop1317_bits[]	= { ANTLR3_UINT64_LIT(0x0000003000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_PRODUCT_OP_in_productop1317	= { FOLLOW_PRODUCT_OP_in_productop1317_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryop_in_productop1321  */
static	ANTLR3_BITWORD FOLLOW_unaryop_in_productop1321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryop_in_productop1321	= { FOLLOW_unaryop_in_productop1321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_unaryop1359  */
static	ANTLR3_BITWORD FOLLOW_36_in_unaryop1359_bits[]	= { ANTLR3_UINT64_LIT(0x0000003000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_unaryop1359	= { FOLLOW_36_in_unaryop1359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atom_in_unaryop1363  */
static	ANTLR3_BITWORD FOLLOW_atom_in_unaryop1363_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atom_in_unaryop1363	= { FOLLOW_atom_in_unaryop1363_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atom_in_unaryop1379  */
static	ANTLR3_BITWORD FOLLOW_atom_in_unaryop1379_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atom_in_unaryop1379	= { FOLLOW_atom_in_unaryop1379_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_atom1404  */
static	ANTLR3_BITWORD FOLLOW_37_in_atom1404_bits[]	= { ANTLR3_UINT64_LIT(0x0000003000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_atom1404	= { FOLLOW_37_in_atom1404_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_atom1408  */
static	ANTLR3_BITWORD FOLLOW_term_in_atom1408_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_atom1408	= { FOLLOW_term_in_atom1408_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_atom1410  */
static	ANTLR3_BITWORD FOLLOW_38_in_atom1410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_atom1410	= { FOLLOW_38_in_atom1410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECIMAL_LITERAL_in_atom1427  */
static	ANTLR3_BITWORD FOLLOW_DECIMAL_LITERAL_in_atom1427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DECIMAL_LITERAL_in_atom1427	= { FOLLOW_DECIMAL_LITERAL_in_atom1427_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_atom1443  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_atom1443_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_atom1443	= { FOLLOW_IDENTIFIER_in_atom1443_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_atom1460  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_atom1460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_atom1460	= { FOLLOW_IDENTIFIER_in_atom1460_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_atom1462  */
static	ANTLR3_BITWORD FOLLOW_33_in_atom1462_bits[]	= { ANTLR3_UINT64_LIT(0x0000003000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_atom1462	= { FOLLOW_33_in_atom1462_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_atom1466  */
static	ANTLR3_BITWORD FOLLOW_term_in_atom1466_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_atom1466	= { FOLLOW_term_in_atom1466_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_atom1468  */
static	ANTLR3_BITWORD FOLLOW_34_in_atom1468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_atom1468	= { FOLLOW_34_in_atom1468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_operation0  */
static	ANTLR3_BITWORD FOLLOW_set_in_operation0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_operation0	= { FOLLOW_set_in_operation0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_synpred18_scma572  */
static	ANTLR3_BITWORD FOLLOW_31_in_synpred18_scma572_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_synpred18_scma572	= { FOLLOW_31_in_synpred18_scma572_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_synpred18_scma574  */
static	ANTLR3_BITWORD FOLLOW_33_in_synpred18_scma574_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_synpred18_scma574	= { FOLLOW_33_in_synpred18_scma574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_synpred18_scma578  */
static	ANTLR3_BITWORD FOLLOW_constant_in_synpred18_scma578_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_synpred18_scma578	= { FOLLOW_constant_in_synpred18_scma578_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_synpred18_scma582  */
static	ANTLR3_BITWORD FOLLOW_34_in_synpred18_scma582_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_synpred18_scma582	= { FOLLOW_34_in_synpred18_scma582_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_synpred21_scma612  */
static	ANTLR3_BITWORD FOLLOW_35_in_synpred21_scma612_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_synpred21_scma612	= { FOLLOW_35_in_synpred21_scma612_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_synpred21_scma614  */
static	ANTLR3_BITWORD FOLLOW_33_in_synpred21_scma614_bits[]	= { ANTLR3_UINT64_LIT(0x0000001400000020) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_synpred21_scma614	= { FOLLOW_33_in_synpred21_scma614_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_synpred21_scma619  */
static	ANTLR3_BITWORD FOLLOW_constant_in_synpred21_scma619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_synpred21_scma619	= { FOLLOW_constant_in_synpred21_scma619_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_synpred21_scma625  */
static	ANTLR3_BITWORD FOLLOW_34_in_synpred21_scma625_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_synpred21_scma625	= { FOLLOW_34_in_synpred21_scma625_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_synpred22_scma640  */
static	ANTLR3_BITWORD FOLLOW_31_in_synpred22_scma640_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_synpred22_scma640	= { FOLLOW_31_in_synpred22_scma640_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_synpred22_scma643  */
static	ANTLR3_BITWORD FOLLOW_33_in_synpred22_scma643_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_synpred22_scma643	= { FOLLOW_33_in_synpred22_scma643_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_synpred22_scma647  */
static	ANTLR3_BITWORD FOLLOW_constant_in_synpred22_scma647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_synpred22_scma647	= { FOLLOW_constant_in_synpred22_scma647_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_synpred22_scma649  */
static	ANTLR3_BITWORD FOLLOW_34_in_synpred22_scma649_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_synpred22_scma649	= { FOLLOW_34_in_synpred22_scma649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_synpred22_scma651  */
static	ANTLR3_BITWORD FOLLOW_33_in_synpred22_scma651_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_synpred22_scma651	= { FOLLOW_33_in_synpred22_scma651_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_synpred22_scma655  */
static	ANTLR3_BITWORD FOLLOW_constant_in_synpred22_scma655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_synpred22_scma655	= { FOLLOW_constant_in_synpred22_scma655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_synpred22_scma657  */
static	ANTLR3_BITWORD FOLLOW_34_in_synpred22_scma657_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_synpred22_scma657	= { FOLLOW_34_in_synpred22_scma657_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_synpred26_scma912  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_synpred26_scma912_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_synpred26_scma912	= { FOLLOW_boolean_expression_in_synpred26_scma912_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_synpred26_scma921  */
static	ANTLR3_BITWORD FOLLOW_23_in_synpred26_scma921_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_synpred26_scma921	= { FOLLOW_23_in_synpred26_scma921_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_synpred31_scma1014  */
static	ANTLR3_BITWORD FOLLOW_37_in_synpred31_scma1014_bits[]	= { ANTLR3_UINT64_LIT(0x0000003000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_synpred31_scma1014	= { FOLLOW_37_in_synpred31_scma1014_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_synpred31_scma1018  */
static	ANTLR3_BITWORD FOLLOW_term_in_synpred31_scma1018_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400040) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_synpred31_scma1018	= { FOLLOW_term_in_synpred31_scma1018_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RELATIONAL_OP_in_synpred31_scma1023  */
static	ANTLR3_BITWORD FOLLOW_RELATIONAL_OP_in_synpred31_scma1023_bits[]	= { ANTLR3_UINT64_LIT(0x0000003000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_RELATIONAL_OP_in_synpred31_scma1023	= { FOLLOW_RELATIONAL_OP_in_synpred31_scma1023_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_synpred31_scma1045  */
static	ANTLR3_BITWORD FOLLOW_22_in_synpred31_scma1045_bits[]	= { ANTLR3_UINT64_LIT(0x0000003000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_synpred31_scma1045	= { FOLLOW_22_in_synpred31_scma1045_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_synpred31_scma1069  */
static	ANTLR3_BITWORD FOLLOW_term_in_synpred31_scma1069_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_synpred31_scma1069	= { FOLLOW_term_in_synpred31_scma1069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_synpred31_scma1071  */
static	ANTLR3_BITWORD FOLLOW_38_in_synpred31_scma1071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_synpred31_scma1071	= { FOLLOW_38_in_synpred31_scma1071_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_synpred32_scma1086  */
static	ANTLR3_BITWORD FOLLOW_37_in_synpred32_scma1086_bits[]	= { ANTLR3_UINT64_LIT(0x000001A000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_synpred32_scma1086	= { FOLLOW_37_in_synpred32_scma1086_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_synpred32_scma1090  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_synpred32_scma1090_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_synpred32_scma1090	= { FOLLOW_boolean_expression_in_synpred32_scma1090_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BOOLEAN_OP_in_synpred32_scma1094  */
static	ANTLR3_BITWORD FOLLOW_BOOLEAN_OP_in_synpred32_scma1094_bits[]	= { ANTLR3_UINT64_LIT(0x000001A000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_BOOLEAN_OP_in_synpred32_scma1094	= { FOLLOW_BOOLEAN_OP_in_synpred32_scma1094_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_synpred32_scma1098  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_synpred32_scma1098_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_synpred32_scma1098	= { FOLLOW_boolean_expression_in_synpred32_scma1098_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_synpred32_scma1100  */
static	ANTLR3_BITWORD FOLLOW_38_in_synpred32_scma1100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_synpred32_scma1100	= { FOLLOW_38_in_synpred32_scma1100_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start translation_unit
 * scma.g:51:1: translation_unit returns [SCTheory * th] : 'theory' (i= IDENTIFIER ) '{' (d= declaration )+ ( 'constants' '{' c1= constant ( ',' c2= constant )* '}' )? ( 'grammar' '{' (r= grammar_rule )+ '}' )? ( 'num_operations_per_clause_bound' '=' c= constant ';' )? ( 'num_quantifiers_bound' '=' c= constant ';' )? ( 'vocab' '{' (v= clause )+ '}' )? '}' ;
 */
static SCTheory *
translation_unit(pscmaParser ctx)
{   
    SCTheory * th = NULL;
    ANTLR3_UINT32 translation_unit_StartIndex;
    pANTLR3_COMMON_TOKEN    i;
    unsigned int d;
    #undef	RETURN_TYPE_d
    #define	RETURN_TYPE_d unsigned int

    int c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 int

    int c2;
    #undef	RETURN_TYPE_c2
    #define	RETURN_TYPE_c2 int

    int c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c int

    int v;
    #undef	RETURN_TYPE_v
    #define	RETURN_TYPE_v int

    /* Initialize rule variables
     */
    translation_unit_StartIndex = INDEX();



      th = 0;
      theory = new SCTheory;
      success = 1;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(1)) )
    {
        {

              cout<<"Parsing Complete"<<endl;
              if (success == 1) {
                th = theory;
              } else {
                delete theory;
              }

        }
        {
        }


        return th; 
    }
    i       = NULL;
    d = NULL;
    c1 = 0;
    c2 = 0;
    c = 0;
    v = 0;

    {
        // scma.g:65:5: ( 'theory' (i= IDENTIFIER ) '{' (d= declaration )+ ( 'constants' '{' c1= constant ( ',' c2= constant )* '}' )? ( 'grammar' '{' (r= grammar_rule )+ '}' )? ( 'num_operations_per_clause_bound' '=' c= constant ';' )? ( 'num_quantifiers_bound' '=' c= constant ';' )? ( 'vocab' '{' (v= clause )+ '}' )? '}' )
        // scma.g:66:1: 'theory' (i= IDENTIFIER ) '{' (d= declaration )+ ( 'constants' '{' c1= constant ( ',' c2= constant )* '}' )? ( 'grammar' '{' (r= grammar_rule )+ '}' )? ( 'num_operations_per_clause_bound' '=' c= constant ';' )? ( 'num_quantifiers_bound' '=' c= constant ';' )? ( 'vocab' '{' (v= clause )+ '}' )? '}'
        {
             MATCHT(15, &FOLLOW_15_in_translation_unit122); 
            if  (HASEXCEPTION())
            {
                goto ruletranslation_unitEx;
            }
            if (HASFAILED())
            {
                return th;
            }
            // scma.g:66:10: (i= IDENTIFIER )
            // scma.g:66:11: i= IDENTIFIER
            {
                i = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_translation_unit127); 
                if  (HASEXCEPTION())
                {
                    goto ruletranslation_unitEx;
                }
                if (HASFAILED())
                {
                    return th;
                }
                if ( BACKTRACKING==0 ) 
                {

                            theory->name = string((const char*)(i->getText(i))->chars);
                            cout << "theory  is " << theory->name << endl;
                            
                }

            }

             MATCHT(16, &FOLLOW_16_in_translation_unit141); 
            if  (HASEXCEPTION())
            {
                goto ruletranslation_unitEx;
            }
            if (HASFAILED())
            {
                return th;
            }
            // scma.g:71:7: (d= declaration )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=2;
            	switch ( LA(1) ) 
            	{
            	case 26:
            	case 27:
            	case 28:
            	case 29:
            	case 30:
            	case 31:
            	case 35:
            		{
            			alt1=1;
            		}
            	    break;

            	}

            	switch (alt1) 
            	{
            	    case 1:
            	        // scma.g:71:8: d= declaration
            	        {
            	            FOLLOWPUSH(FOLLOW_declaration_in_translation_unit146);
            	            d=declaration(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletranslation_unitEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return th;
            	            }
            	            if ( BACKTRACKING==0 ) 
            	            {


            	                        
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return th;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruletranslation_unitEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

            // scma.g:76:1: ( 'constants' '{' c1= constant ( ',' c2= constant )* '}' )?
            {
                int alt3=2;
                switch ( LA(1) ) 
                {
                    case 17:
                    	{
                    		alt3=1;
                    	}
                        break;
                }

                switch (alt3) 
                {
            	case 1:
            	    // scma.g:76:3: 'constants' '{' c1= constant ( ',' c2= constant )* '}'
            	    {
            	         MATCHT(17, &FOLLOW_17_in_translation_unit165); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	         MATCHT(16, &FOLLOW_16_in_translation_unit167); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	        FOLLOWPUSH(FOLLOW_constant_in_translation_unit171);
            	        c1=constant(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	                      theory->handleConstantDeclaration(c1);
            	                    
            	        }

            	        // scma.g:80:1: ( ',' c2= constant )*

            	        for (;;)
            	        {
            	            int alt2=2;
            	            switch ( LA(1) ) 
            	            {
            	            case 18:
            	            	{
            	            		alt2=1;
            	            	}
            	                break;

            	            }

            	            switch (alt2) 
            	            {
            	        	case 1:
            	        	    // scma.g:80:2: ',' c2= constant
            	        	    {
            	        	         MATCHT(18, &FOLLOW_18_in_translation_unit185); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletranslation_unitEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return th;
            	        	        }
            	        	        FOLLOWPUSH(FOLLOW_constant_in_translation_unit189);
            	        	        c2=constant(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletranslation_unitEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return th;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) 
            	        	        {

            	        	                      theory->handleConstantDeclaration(c2);
            	        	                    
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop2;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop2: ; /* Jump out to here if this rule does not match */

            	         MATCHT(19, &FOLLOW_19_in_translation_unit204); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }

            	    }
            	    break;

                }
            }

            // scma.g:85:1: ( 'grammar' '{' (r= grammar_rule )+ '}' )?
            {
                int alt5=2;
                switch ( LA(1) ) 
                {
                    case 20:
                    	{
                    		alt5=1;
                    	}
                        break;
                }

                switch (alt5) 
                {
            	case 1:
            	    // scma.g:85:3: 'grammar' '{' (r= grammar_rule )+ '}'
            	    {
            	         MATCHT(20, &FOLLOW_20_in_translation_unit211); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	         MATCHT(16, &FOLLOW_16_in_translation_unit213); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	        // scma.g:85:17: (r= grammar_rule )+
            	        {
            	            int cnt4=0;

            	            for (;;)
            	            {
            	                int alt4=2;
            	        	switch ( LA(1) ) 
            	        	{
            	        	case 37:
            	        		{
            	        			alt4=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt4) 
            	        	{
            	        	    case 1:
            	        	        // scma.g:85:18: r= grammar_rule
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_grammar_rule_in_translation_unit218);
            	        	            grammar_rule(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto ruletranslation_unitEx;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                return th;
            	        	            }
            	        	            if ( BACKTRACKING==0 ) 
            	        	            {

            	        	                        
            	        	            }

            	        	        }
            	        	        break;

            	        	    default:
            	        	    
            	        		if ( cnt4 >= 1 )
            	        		{
            	        		    goto loop4;
            	        		}
            	        		if (BACKTRACKING>0)
            	        		{
            	        		    FAILEDFLAG = ANTLR3_TRUE;
            	        		    return th;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto ruletranslation_unitEx;
            	        	}
            	        	cnt4++;
            	            }
            	            loop4: ;	/* Jump to here if this rule does not match */
            	        }
            	         MATCHT(19, &FOLLOW_19_in_translation_unit233); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }

            	    }
            	    break;

                }
            }

            // scma.g:89:1: ( 'num_operations_per_clause_bound' '=' c= constant ';' )?
            {
                int alt6=2;
                switch ( LA(1) ) 
                {
                    case 21:
                    	{
                    		alt6=1;
                    	}
                        break;
                }

                switch (alt6) 
                {
            	case 1:
            	    // scma.g:89:3: 'num_operations_per_clause_bound' '=' c= constant ';'
            	    {
            	         MATCHT(21, &FOLLOW_21_in_translation_unit239); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	         MATCHT(22, &FOLLOW_22_in_translation_unit241); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	        FOLLOWPUSH(FOLLOW_constant_in_translation_unit245);
            	        c=constant(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	                      theory->numClauseOperationBound = c;
            	                    
            	        }
            	         MATCHT(23, &FOLLOW_23_in_translation_unit258); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }

            	    }
            	    break;

                }
            }

            // scma.g:94:1: ( 'num_quantifiers_bound' '=' c= constant ';' )?
            {
                int alt7=2;
                switch ( LA(1) ) 
                {
                    case 24:
                    	{
                    		alt7=1;
                    	}
                        break;
                }

                switch (alt7) 
                {
            	case 1:
            	    // scma.g:94:3: 'num_quantifiers_bound' '=' c= constant ';'
            	    {
            	         MATCHT(24, &FOLLOW_24_in_translation_unit264); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	         MATCHT(22, &FOLLOW_22_in_translation_unit266); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	        FOLLOWPUSH(FOLLOW_constant_in_translation_unit270);
            	        c=constant(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	                      theory->numQuantifierBound = c;
            	                    
            	        }
            	         MATCHT(23, &FOLLOW_23_in_translation_unit283); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }

            	    }
            	    break;

                }
            }

            // scma.g:100:1: ( 'vocab' '{' (v= clause )+ '}' )?
            {
                int alt9=2;
                switch ( LA(1) ) 
                {
                    case 25:
                    	{
                    		alt9=1;
                    	}
                        break;
                }

                switch (alt9) 
                {
            	case 1:
            	    // scma.g:100:3: 'vocab' '{' (v= clause )+ '}'
            	    {
            	         MATCHT(25, &FOLLOW_25_in_translation_unit290); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	         MATCHT(16, &FOLLOW_16_in_translation_unit292); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }
            	        // scma.g:100:15: (v= clause )+
            	        {
            	            int cnt8=0;

            	            for (;;)
            	            {
            	                int alt8=2;
            	        	switch ( LA(1) ) 
            	        	{
            	        	case IDENTIFIER:
            	        	case 37:
            	        	case 39:
            	        	case 40:
            	        		{
            	        			alt8=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt8) 
            	        	{
            	        	    case 1:
            	        	        // scma.g:100:16: v= clause
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_clause_in_translation_unit297);
            	        	            v=clause(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto ruletranslation_unitEx;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                return th;
            	        	            }
            	        	            if ( BACKTRACKING==0 ) 
            	        	            {

            	        	                        
            	        	            }

            	        	        }
            	        	        break;

            	        	    default:
            	        	    
            	        		if ( cnt8 >= 1 )
            	        		{
            	        		    goto loop8;
            	        		}
            	        		if (BACKTRACKING>0)
            	        		{
            	        		    FAILEDFLAG = ANTLR3_TRUE;
            	        		    return th;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto ruletranslation_unitEx;
            	        	}
            	        	cnt8++;
            	            }
            	            loop8: ;	/* Jump to here if this rule does not match */
            	        }
            	         MATCHT(19, &FOLLOW_19_in_translation_unit312); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return th;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(19, &FOLLOW_19_in_translation_unit316); 
            if  (HASEXCEPTION())
            {
                goto ruletranslation_unitEx;
            }
            if (HASFAILED())
            {
                return th;
            }
            if ( BACKTRACKING==0 ) 
            {


                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletranslation_unitEx; /* Prevent compiler warnings */
    ruletranslation_unitEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                      cout<<"Parsing Complete"<<endl;
                      if (success == 1) {
                        th = theory;
                      } else {
                        delete theory;
                      }

                }
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(1, translation_unit_StartIndex); }

    return th;
}
/* $ANTLR end translation_unit */

/** 
 * $ANTLR start declaration
 * scma.g:111:1: declaration returns [unsigned int varid ] : e= declaration_specifier j= declarator ( '=' d= constant )? ';' ;
 */
static unsigned int
declaration(pscmaParser ctx)
{   
    unsigned int varid = NULL;
    ANTLR3_UINT32 declaration_StartIndex;
    scmaParser_declaration_specifier_return e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e scmaParser_declaration_specifier_return

    scstring j;
    #undef	RETURN_TYPE_j
    #define	RETURN_TYPE_j scstring

    int d;
    #undef	RETURN_TYPE_d
    #define	RETURN_TYPE_d int

    /* Initialize rule variables
     */
    declaration_StartIndex = INDEX();



      int value = 0;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(2)) )
    {

        {
        }


        return varid; 
    }
    j = NULL;
    d = 0;

    {
        // scma.g:115:5: (e= declaration_specifier j= declarator ( '=' d= constant )? ';' )
        // scma.g:116:1: e= declaration_specifier j= declarator ( '=' d= constant )? ';'
        {
            FOLLOWPUSH(FOLLOW_declaration_specifier_in_declaration352);
            e=declaration_specifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclarationEx;
            }
            if (HASFAILED())
            {
                return varid;
            }
            FOLLOWPUSH(FOLLOW_declarator_in_declaration356);
            j=declarator(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclarationEx;
            }
            if (HASFAILED())
            {
                return varid;
            }

            // scma.g:116:38: ( '=' d= constant )?
            {
                int alt10=2;
                switch ( LA(1) ) 
                {
                    case 22:
                    	{
                    		alt10=1;
                    	}
                        break;
                }

                switch (alt10) 
                {
            	case 1:
            	    // scma.g:116:39: '=' d= constant
            	    {
            	         MATCHT(22, &FOLLOW_22_in_declaration359); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return varid;
            	        }
            	        FOLLOWPUSH(FOLLOW_constant_in_declaration363);
            	        d=constant(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return varid;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	            			value = d;
            	            	 	
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {

                        // search for variable in map, if found return error
                        // if not then create a new with the appropriate types 
                        string name = (j);
                        varid = theory->handleDeclaration(name, e.type, 
                            e.mode, 
                            e.size, e.rows, e.cols,value);
                    
            }
             MATCHT(23, &FOLLOW_23_in_declaration378); 
            if  (HASEXCEPTION())
            {
                goto ruledeclarationEx;
            }
            if (HASFAILED())
            {
                return varid;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledeclarationEx; /* Prevent compiler warnings */
    ruledeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(2, declaration_StartIndex); }

    return varid;
}
/* $ANTLR end declaration */

/** 
 * $ANTLR start declaration_specifier
 * scma.g:131:1: declaration_specifier returns [string type, unsigned int mode, int size, int rows, int cols] : (m= type_modifier )* (e= type_specifier ) ;
 */
static scmaParser_declaration_specifier_return
declaration_specifier(pscmaParser ctx)
{   
    scmaParser_declaration_specifier_return retval;
    ANTLR3_UINT32 declaration_specifier_StartIndex;
    unsigned int m;
    #undef	RETURN_TYPE_m
    #define	RETURN_TYPE_m unsigned int

    scmaParser_type_specifier_return e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e scmaParser_type_specifier_return

    /* Initialize rule variables
     */
    declaration_specifier_StartIndex = INDEX();



      retval.mode= 0;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(3)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    m = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        // scma.g:135:5: ( (m= type_modifier )* (e= type_specifier ) )
        // scma.g:136:1: (m= type_modifier )* (e= type_specifier )
        {

            // scma.g:136:1: (m= type_modifier )*

            for (;;)
            {
                int alt11=2;
                switch ( LA(1) ) 
                {
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                	{
                		alt11=1;
                	}
                    break;

                }

                switch (alt11) 
                {
            	case 1:
            	    // scma.g:136:2: m= type_modifier
            	    {
            	        FOLLOWPUSH(FOLLOW_type_modifier_in_declaration_specifier409);
            	        m=type_modifier(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclaration_specifierEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	             retval.mode= m;
            	             
            	        }

            	    }
            	    break;

            	default:
            	    goto loop11;	/* break out of the loop */
            	    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */

            // scma.g:140:4: (e= type_specifier )
            // scma.g:140:5: e= type_specifier
            {
                FOLLOWPUSH(FOLLOW_type_specifier_in_declaration_specifier421);
                e=type_specifier(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruledeclaration_specifierEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) 
                {

                              retval.type= e.type;
                              retval.size= e.size;
                              retval.rows= e.rows;
                              retval.cols= e.cols;
                            
                }

            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledeclaration_specifierEx; /* Prevent compiler warnings */
    ruledeclaration_specifierEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(3, declaration_specifier_StartIndex); }

    return retval;
}
/* $ANTLR end declaration_specifier */

/** 
 * $ANTLR start type_modifier
 * scma.g:150:1: type_modifier returns [unsigned int mode] : ( 'const' | 'universal' | 'global' | 'existential' | 'local' );
 */
static unsigned int
type_modifier(pscmaParser ctx)
{   
    unsigned int mode = NULL;
    ANTLR3_UINT32 type_modifier_StartIndex;
    /* Initialize rule variables
     */
    type_modifier_StartIndex = INDEX();



      mode= 0;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(4)) )
    {

        {
        }


        return mode; 
    }
    {
        {
            //  scma.g:154:1: ( 'const' | 'universal' | 'global' | 'existential' | 'local' )
            
            ANTLR3_UINT32 alt12;

            alt12=5;

            switch ( LA(1) ) 
            {
            case 26:
            	{
            		alt12=1;
            	}
                break;
            case 27:
            	{
            		alt12=2;
            	}
                break;
            case 28:
            	{
            		alt12=3;
            	}
                break;
            case 29:
            	{
            		alt12=4;
            	}
                break;
            case 30:
            	{
            		alt12=5;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return mode;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 12;
                EXCEPTION->state        = 0;


                goto ruletype_modifierEx;
            }

            switch (alt12) 
            {
        	case 1:
        	    // scma.g:155:1: 'const'
        	    {
        	         MATCHT(26, &FOLLOW_26_in_type_modifier454); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_modifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return mode;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             mode |= NODE_CONSTANT;
        	        }

        	    }
        	    break;
        	case 2:
        	    // scma.g:156:1: 'universal'
        	    {
        	         MATCHT(27, &FOLLOW_27_in_type_modifier461); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_modifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return mode;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             mode |= NODE_GLOBAL;
        	        }

        	    }
        	    break;
        	case 3:
        	    // scma.g:157:1: 'global'
        	    {
        	         MATCHT(28, &FOLLOW_28_in_type_modifier467); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_modifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return mode;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             mode |= NODE_GLOBAL;
        	        }

        	    }
        	    break;
        	case 4:
        	    // scma.g:158:1: 'existential'
        	    {
        	         MATCHT(29, &FOLLOW_29_in_type_modifier473); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_modifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return mode;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             mode |= NODE_LOCAL;
        	        }

        	    }
        	    break;
        	case 5:
        	    // scma.g:159:1: 'local'
        	    {
        	         MATCHT(30, &FOLLOW_30_in_type_modifier480); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_modifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return mode;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             mode |= NODE_LOCAL;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletype_modifierEx; /* Prevent compiler warnings */
    ruletype_modifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(4, type_modifier_StartIndex); }

    return mode;
}
/* $ANTLR end type_modifier */

/** 
 * $ANTLR start declarator
 * scma.g:165:1: declarator returns [scstring varname] : e= direct_declarator ;
 */
static scstring
declarator(pscmaParser ctx)
{   
    scstring varname = NULL;
    ANTLR3_UINT32 declarator_StartIndex;
    scstring e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e scstring

    /* Initialize rule variables
     */
    declarator_StartIndex = INDEX();


    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(5)) )
    {

        {
        }


        return varname; 
    }
    e = NULL;

    {
        // scma.g:166:5: (e= direct_declarator )
        // scma.g:166:7: e= direct_declarator
        {
            FOLLOWPUSH(FOLLOW_direct_declarator_in_declarator503);
            e=direct_declarator(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclaratorEx;
            }
            if (HASFAILED())
            {
                return varname;
            }
            if ( BACKTRACKING==0 ) 
            {
                varname= e;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledeclaratorEx; /* Prevent compiler warnings */
    ruledeclaratorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(5, declarator_StartIndex); }

    return varname;
}
/* $ANTLR end declarator */

/** 
 * $ANTLR start type_specifier
 * scma.g:170:1: type_specifier returns [scstring type, int size, int rows, int cols] : ( 'int' | 'int' '[]' | 'int' '[' s= constant ']' | 'boolean' | 'boolean' '[' (s= constant )? ']' | 'int' '[' s= constant ']' '[' q= constant ']' | 'boolean' '[' s= constant ']' '[' q= constant ']' );
 */
static scmaParser_type_specifier_return
type_specifier(pscmaParser ctx)
{   
    scmaParser_type_specifier_return retval;
    ANTLR3_UINT32 type_specifier_StartIndex;
    int s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s int

    int q;
    #undef	RETURN_TYPE_q
    #define	RETURN_TYPE_q int

    /* Initialize rule variables
     */
    type_specifier_StartIndex = INDEX();



      retval.rows= retval.cols = retval.size = -1;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(6)) )
    {
    	retval.start = 0;
        {

            	if (retval.size == -1) {
            		retval.size= 0;
            	}
              if (retval.rows == -1) {
                retval.rows= 0;
              }

        }
        {
        }


        return retval; 
    }
    s = 0;
    q = 0;
    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  scma.g:183:5: ( 'int' | 'int' '[]' | 'int' '[' s= constant ']' | 'boolean' | 'boolean' '[' (s= constant )? ']' | 'int' '[' s= constant ']' '[' q= constant ']' | 'boolean' '[' s= constant ']' '[' q= constant ']' )
            
            ANTLR3_UINT32 alt14;

            alt14=7;

            switch ( LA(1) ) 
            {
            case 31:
            	{
            		switch ( LA(2) ) 
            		{
            		case 32:
            			{
            				alt14=2;
            			}
            		    break;
            		case 33:
            			{
            				switch ( LA(3) ) 
            				{
            				case 36:
            					{

            						{
            						    int LA14_8 = LA(4);
            						    if ( (synpred18_scma(ctx)) ) 
            						    {
            						        alt14=3;
            						    }
            						    else if ( (synpred22_scma(ctx)) ) 
            						    {
            						        alt14=6;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return retval;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 14;
            						        EXCEPTION->state        = 8;


            						        goto ruletype_specifierEx;
            						    }
            						}
            					}
            				    break;
            				case DECIMAL_LITERAL:
            					{

            						{
            						    int LA14_9 = LA(4);
            						    if ( (synpred18_scma(ctx)) ) 
            						    {
            						        alt14=3;
            						    }
            						    else if ( (synpred22_scma(ctx)) ) 
            						    {
            						        alt14=6;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return retval;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 14;
            						        EXCEPTION->state        = 9;


            						        goto ruletype_specifierEx;
            						    }
            						}
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return retval;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 14;
            				    EXCEPTION->state        = 4;


            				    goto ruletype_specifierEx;
            				}

            			}
            		    break;
            		case IDENTIFIER:
            			{
            				alt14=1;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 14;
            		    EXCEPTION->state        = 1;


            		    goto ruletype_specifierEx;
            		}

            	}
                break;
            case 35:
            	{
            		switch ( LA(2) ) 
            		{
            		case 33:
            			{
            				switch ( LA(3) ) 
            				{
            				case 36:
            					{

            						{
            						    int LA14_10 = LA(4);
            						    if ( (synpred21_scma(ctx)) ) 
            						    {
            						        alt14=5;
            						    }
            						    else if ( (ANTLR3_TRUE) ) 
            						    {
            						        alt14=7;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return retval;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 14;
            						        EXCEPTION->state        = 10;


            						        goto ruletype_specifierEx;
            						    }
            						}
            					}
            				    break;
            				case DECIMAL_LITERAL:
            					{

            						{
            						    int LA14_11 = LA(4);
            						    if ( (synpred21_scma(ctx)) ) 
            						    {
            						        alt14=5;
            						    }
            						    else if ( (ANTLR3_TRUE) ) 
            						    {
            						        alt14=7;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return retval;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 14;
            						        EXCEPTION->state        = 11;


            						        goto ruletype_specifierEx;
            						    }
            						}
            					}
            				    break;
            				case 34:
            					{
            						alt14=5;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return retval;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 14;
            				    EXCEPTION->state        = 6;


            				    goto ruletype_specifierEx;
            				}

            			}
            		    break;
            		case IDENTIFIER:
            			{
            				alt14=4;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 14;
            		    EXCEPTION->state        = 2;


            		    goto ruletype_specifierEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 14;
                EXCEPTION->state        = 0;


                goto ruletype_specifierEx;
            }

            switch (alt14) 
            {
        	case 1:
        	    // scma.g:184:1: 'int'
        	    {
        	         MATCHT(31, &FOLLOW_31_in_type_specifier540); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        retval.type= "int"; //  return integer type
        	                    
        	        }

        	    }
        	    break;
        	case 2:
        	    // scma.g:188:3: 'int' '[]'
        	    {
        	         MATCHT(31, &FOLLOW_31_in_type_specifier555); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	         MATCHT(32, &FOLLOW_32_in_type_specifier557); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        retval.type= "array"; // return integer array type 
        	                    
        	        }

        	    }
        	    break;
        	case 3:
        	    // scma.g:192:3: 'int' '[' s= constant ']'
        	    {
        	         MATCHT(31, &FOLLOW_31_in_type_specifier572); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	         MATCHT(33, &FOLLOW_33_in_type_specifier574); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_constant_in_type_specifier578);
        	        s=constant(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.size= s;
        	        }
        	         MATCHT(34, &FOLLOW_34_in_type_specifier582); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        retval.type= "array"; // return integer array type 
        	                    
        	        }

        	    }
        	    break;
        	case 4:
        	    // scma.g:196:3: 'boolean'
        	    {
        	         MATCHT(35, &FOLLOW_35_in_type_specifier597); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        retval.type= "bool"; // return boolean type
        	                    
        	        }

        	    }
        	    break;
        	case 5:
        	    // scma.g:200:3: 'boolean' '[' (s= constant )? ']'
        	    {
        	         MATCHT(35, &FOLLOW_35_in_type_specifier612); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	         MATCHT(33, &FOLLOW_33_in_type_specifier614); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        // scma.g:200:17: (s= constant )?
        	        {
        	            int alt13=2;
        	            switch ( LA(1) ) 
        	            {
        	                case DECIMAL_LITERAL:
        	                case 36:
        	                	{
        	                		alt13=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt13) 
        	            {
        	        	case 1:
        	        	    // scma.g:200:18: s= constant
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_constant_in_type_specifier619);
        	        	        s=constant(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletype_specifierEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) 
        	        	        {
        	        	            retval.size= s;
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }
        	         MATCHT(34, &FOLLOW_34_in_type_specifier625); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        retval.type= "barray"; // return boolean array type
        	                    
        	        }

        	    }
        	    break;
        	case 6:
        	    // scma.g:204:3: 'int' '[' s= constant ']' '[' q= constant ']'
        	    {
        	         MATCHT(31, &FOLLOW_31_in_type_specifier640); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	         MATCHT(33, &FOLLOW_33_in_type_specifier643); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_constant_in_type_specifier647);
        	        s=constant(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	         MATCHT(34, &FOLLOW_34_in_type_specifier649); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	         MATCHT(33, &FOLLOW_33_in_type_specifier651); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_constant_in_type_specifier655);
        	        q=constant(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	         MATCHT(34, &FOLLOW_34_in_type_specifier657); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                     retval.type= "matrix";
        	                     retval.rows= s;
        	                     retval.cols= q;
        	                   
        	        }

        	    }
        	    break;
        	case 7:
        	    // scma.g:210:3: 'boolean' '[' s= constant ']' '[' q= constant ']'
        	    {
        	         MATCHT(35, &FOLLOW_35_in_type_specifier669); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	         MATCHT(33, &FOLLOW_33_in_type_specifier671); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_constant_in_type_specifier675);
        	        s=constant(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	         MATCHT(34, &FOLLOW_34_in_type_specifier677); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	         MATCHT(33, &FOLLOW_33_in_type_specifier679); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_constant_in_type_specifier683);
        	        q=constant(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	         MATCHT(34, &FOLLOW_34_in_type_specifier685); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_specifierEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                     retval.type= "bmatrix"; // return boolean matrix type
        	                     retval.rows= s;
        	                     retval.cols= q;
        	                   
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletype_specifierEx; /* Prevent compiler warnings */
    ruletype_specifierEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	if (retval.size == -1) {
                    		retval.size= 0;
                    	}
                      if (retval.rows == -1) {
                        retval.rows= 0;
                      }

                }
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(6, type_specifier_StartIndex); }

    return retval;
}
/* $ANTLR end type_specifier */

/** 
 * $ANTLR start direct_declarator
 * scma.g:222:1: direct_declarator returns [scstring varname ] : e= IDENTIFIER ;
 */
static scstring
direct_declarator(pscmaParser ctx)
{   
    scstring varname = NULL;
    ANTLR3_UINT32 direct_declarator_StartIndex;
    pANTLR3_COMMON_TOKEN    e;

    /* Initialize rule variables
     */
    direct_declarator_StartIndex = INDEX();


    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(7)) )
    {

        {
        }


        return varname; 
    }
    e       = NULL;

    {
        // scma.g:223:5: (e= IDENTIFIER )
        // scma.g:223:9: e= IDENTIFIER
        {
            e = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_direct_declarator717); 
            if  (HASEXCEPTION())
            {
                goto ruledirect_declaratorEx;
            }
            if (HASFAILED())
            {
                return varname;
            }
            if ( BACKTRACKING==0 ) 
            {

                       varname = string((const char*)(e->getText(e))->chars);
                     
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledirect_declaratorEx; /* Prevent compiler warnings */
    ruledirect_declaratorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(7, direct_declarator_StartIndex); }

    return varname;
}
/* $ANTLR end direct_declarator */

/** 
 * $ANTLR start constant
 * scma.g:230:1: constant returns [ int value] : ( '-' )? e= DECIMAL_LITERAL ;
 */
static int
constant(pscmaParser ctx)
{   
    int value = 0;
    ANTLR3_UINT32 constant_StartIndex;
    pANTLR3_COMMON_TOKEN    e;

    /* Initialize rule variables
     */
    constant_StartIndex = INDEX();



      bool sign = false;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(8)) )
    {

        {
        }


        return value; 
    }
    e       = NULL;

    {
        // scma.g:234:5: ( ( '-' )? e= DECIMAL_LITERAL )
        // scma.g:235:1: ( '-' )? e= DECIMAL_LITERAL
        {

            // scma.g:235:1: ( '-' )?
            {
                int alt15=2;
                switch ( LA(1) ) 
                {
                    case 36:
                    	{
                    		alt15=1;
                    	}
                        break;
                }

                switch (alt15) 
                {
            	case 1:
            	    // scma.g:235:3: '-'
            	    {
            	         MATCHT(36, &FOLLOW_36_in_constant755); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstantEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	                    sign = true;
            	                    
            	        }

            	    }
            	    break;

                }
            }
            e = (pANTLR3_COMMON_TOKEN) MATCHT(DECIMAL_LITERAL, &FOLLOW_DECIMAL_LITERAL_in_constant772); 
            if  (HASEXCEPTION())
            {
                goto ruleconstantEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                             value= atoi((const char*)(e->getText(e))->chars);
                             if (sign) {
                               value= -value;
                             }
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstantEx; /* Prevent compiler warnings */
    ruleconstantEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(8, constant_StartIndex); }

    return value;
}
/* $ANTLR end constant */

/** 
 * $ANTLR start grammar_rule
 * scma.g:249:1: grammar_rule : '(' i1= IDENTIFIER ',' (i2= IDENTIFIER | c= constant ) ',' o= operation ( ',' o2= operation )* ')' ';' ;
 */
static void
grammar_rule(pscmaParser ctx)
{   
    ANTLR3_UINT32 grammar_rule_StartIndex;
    pANTLR3_COMMON_TOKEN    i1;
    pANTLR3_COMMON_TOKEN    i2;
    int c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c int

    scmaParser_operation_return o;
    #undef	RETURN_TYPE_o
    #define	RETURN_TYPE_o scmaParser_operation_return

    scmaParser_operation_return o2;
    #undef	RETURN_TYPE_o2
    #define	RETURN_TYPE_o2 scmaParser_operation_return

    /* Initialize rule variables
     */
    grammar_rule_StartIndex = INDEX();



      int n1=-1;
      int n2=-1;
      set<string> ops;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(9)) )
    {

        {
        }


        return ; 
    }
    i1       = NULL;
    i2       = NULL;
    c = 0;

    {
        // scma.g:255:1: ( '(' i1= IDENTIFIER ',' (i2= IDENTIFIER | c= constant ) ',' o= operation ( ',' o2= operation )* ')' ';' )
        // scma.g:256:1: '(' i1= IDENTIFIER ',' (i2= IDENTIFIER | c= constant ) ',' o= operation ( ',' o2= operation )* ')' ';'
        {
             MATCHT(37, &FOLLOW_37_in_grammar_rule803); 
            if  (HASEXCEPTION())
            {
                goto rulegrammar_ruleEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            i1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_grammar_rule807); 
            if  (HASEXCEPTION())
            {
                goto rulegrammar_ruleEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                      string name((const char*)(i1->getText(i1))->chars);
                      n1 = theory->getIdOfUsedVarible(name, SCTheory::SC_GRAMMAR);
                      
            }
             MATCHT(18, &FOLLOW_18_in_grammar_rule819); 
            if  (HASEXCEPTION())
            {
                goto rulegrammar_ruleEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // scma.g:262:5: (i2= IDENTIFIER | c= constant )
            {
                int alt16=2;
                switch ( LA(1) ) 
                {
                case IDENTIFIER:
                	{
                		alt16=1;
                	}
                    break;
                case DECIMAL_LITERAL:
                case 36:
                	{
                		alt16=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 16;
                    EXCEPTION->state        = 0;


                    goto rulegrammar_ruleEx;
                }

                switch (alt16) 
                {
            	case 1:
            	    // scma.g:262:6: i2= IDENTIFIER
            	    {
            	        i2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_grammar_rule824); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegrammar_ruleEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	                  string name((const char*)(i2->getText(i2))->chars);
            	                  n2 = theory->getIdOfUsedVarible(name, SCTheory::SC_GRAMMAR);
            	                  
            	        }

            	    }
            	    break;
            	case 2:
            	    // scma.g:267:3: c= constant
            	    {
            	        FOLLOWPUSH(FOLLOW_constant_in_grammar_rule839);
            	        c=constant(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegrammar_ruleEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	                  n2 = theory->getIdOfUsedConstant(c, SCTheory::SC_GRAMMAR);
            	                  
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(18, &FOLLOW_18_in_grammar_rule851); 
            if  (HASEXCEPTION())
            {
                goto rulegrammar_ruleEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_operation_in_grammar_rule855);
            o=operation(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegrammar_ruleEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                        string op((const char*)(STRSTREAM->toStringTT(STRSTREAM, o.start, o.stop))->chars);
                        ops.insert(op);
                      
            }

            // scma.g:277:1: ( ',' o2= operation )*

            for (;;)
            {
                int alt17=2;
                switch ( LA(1) ) 
                {
                case 18:
                	{
                		alt17=1;
                	}
                    break;

                }

                switch (alt17) 
                {
            	case 1:
            	    // scma.g:277:2: ',' o2= operation
            	    {
            	         MATCHT(18, &FOLLOW_18_in_grammar_rule866); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegrammar_ruleEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_operation_in_grammar_rule870);
            	        o2=operation(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegrammar_ruleEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	                    string op((const char*)(STRSTREAM->toStringTT(STRSTREAM, o2.start, o2.stop))->chars);
            	                    ops.insert(op);
            	                  
            	        }

            	    }
            	    break;

            	default:
            	    goto loop17;	/* break out of the loop */
            	    break;
                }
            }
            loop17: ; /* Jump out to here if this rule does not match */

             MATCHT(38, &FOLLOW_38_in_grammar_rule884); 
            if  (HASEXCEPTION())
            {
                goto rulegrammar_ruleEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                        if (n1 == -1 || n2 == -1 ){
                          cerr << "SPCHK: warning: ignoring grammar rule." << endl;
                        } else {
                          theory->handleGrammarRule(n1, n2, ops);
                        }
                      
            }
             MATCHT(23, &FOLLOW_23_in_grammar_rule894); 
            if  (HASEXCEPTION())
            {
                goto rulegrammar_ruleEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulegrammar_ruleEx; /* Prevent compiler warnings */
    rulegrammar_ruleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(9, grammar_rule_StartIndex); }

    return ;
}
/* $ANTLR end grammar_rule */

/** 
 * $ANTLR start clause
 * scma.g:294:1: clause returns [int nodeid] : (be= boolean_expression ';' | '(' be= boolean_expression ')' ';' );
 */
static int
clause(pscmaParser ctx)
{   
    int nodeid = 0;
    ANTLR3_UINT32 clause_StartIndex;
    int be;
    #undef	RETURN_TYPE_be
    #define	RETURN_TYPE_be int

    /* Initialize rule variables
     */
    clause_StartIndex = INDEX();


    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(10)) )
    {

        {
        }


        return nodeid; 
    }
    be = 0;

    {
        {
            //  scma.g:294:29: (be= boolean_expression ';' | '(' be= boolean_expression ')' ';' )
            
            ANTLR3_UINT32 alt18;

            alt18=2;

            switch ( LA(1) ) 
            {
            case IDENTIFIER:
            case 39:
            case 40:
            	{
            		alt18=1;
            	}
                break;
            case 37:
            	{
            		switch ( LA(2) ) 
            		{
            		case DECIMAL_LITERAL:
            		case 36:
            		case 41:
            		case 42:
            		case 43:
            		case 45:
            			{
            				alt18=1;
            			}
            		    break;
            		case 39:
            			{
            				switch ( LA(3) ) 
            				{
            				case 38:
            					{
            						alt18=2;
            					}
            				    break;
            				case BOOLEAN_OP:
            					{
            						alt18=1;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return nodeid;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 18;
            				    EXCEPTION->state        = 8;


            				    goto ruleclauseEx;
            				}

            			}
            		    break;
            		case 40:
            			{
            				switch ( LA(3) ) 
            				{
            				case BOOLEAN_OP:
            					{
            						alt18=1;
            					}
            				    break;
            				case 38:
            					{
            						alt18=2;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return nodeid;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 18;
            				    EXCEPTION->state        = 9;


            				    goto ruleclauseEx;
            				}

            			}
            		    break;
            		case IDENTIFIER:
            			{
            				switch ( LA(3) ) 
            				{
            				case RELATIONAL_OP:
            				case BOOLEAN_OP:
            				case ADDITION_OP:
            				case PRODUCT_OP:
            				case 22:
            				case 33:
            					{
            						alt18=1;
            					}
            				    break;
            				case 38:
            					{
            						alt18=2;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return nodeid;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 18;
            				    EXCEPTION->state        = 10;


            				    goto ruleclauseEx;
            				}

            			}
            		    break;
            		case 37:
            			{
            				switch ( LA(3) ) 
            				{
            				case 41:
            				case 42:
            					{

            						{
            						    int LA18_25 = LA(4);
            						    if ( (synpred26_scma(ctx)) ) 
            						    {
            						        alt18=1;
            						    }
            						    else if ( (ANTLR3_TRUE) ) 
            						    {
            						        alt18=2;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 18;
            						        EXCEPTION->state        = 25;


            						        goto ruleclauseEx;
            						    }
            						}
            					}
            				    break;
            				case 43:
            					{

            						{
            						    int LA18_26 = LA(4);
            						    if ( (synpred26_scma(ctx)) ) 
            						    {
            						        alt18=1;
            						    }
            						    else if ( (ANTLR3_TRUE) ) 
            						    {
            						        alt18=2;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 18;
            						        EXCEPTION->state        = 26;


            						        goto ruleclauseEx;
            						    }
            						}
            					}
            				    break;
            				case 45:
            					{

            						{
            						    int LA18_27 = LA(4);
            						    if ( (synpred26_scma(ctx)) ) 
            						    {
            						        alt18=1;
            						    }
            						    else if ( (ANTLR3_TRUE) ) 
            						    {
            						        alt18=2;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 18;
            						        EXCEPTION->state        = 27;


            						        goto ruleclauseEx;
            						    }
            						}
            					}
            				    break;
            				case 36:
            					{

            						{
            						    int LA18_28 = LA(4);
            						    if ( (synpred26_scma(ctx)) ) 
            						    {
            						        alt18=1;
            						    }
            						    else if ( (ANTLR3_TRUE) ) 
            						    {
            						        alt18=2;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 18;
            						        EXCEPTION->state        = 28;


            						        goto ruleclauseEx;
            						    }
            						}
            					}
            				    break;
            				case 37:
            					{

            						{
            						    int LA18_29 = LA(4);
            						    if ( (synpred26_scma(ctx)) ) 
            						    {
            						        alt18=1;
            						    }
            						    else if ( (ANTLR3_TRUE) ) 
            						    {
            						        alt18=2;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 18;
            						        EXCEPTION->state        = 29;


            						        goto ruleclauseEx;
            						    }
            						}
            					}
            				    break;
            				case DECIMAL_LITERAL:
            					{

            						{
            						    int LA18_30 = LA(4);
            						    if ( (synpred26_scma(ctx)) ) 
            						    {
            						        alt18=1;
            						    }
            						    else if ( (ANTLR3_TRUE) ) 
            						    {
            						        alt18=2;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 18;
            						        EXCEPTION->state        = 30;


            						        goto ruleclauseEx;
            						    }
            						}
            					}
            				    break;
            				case IDENTIFIER:
            					{

            						{
            						    int LA18_31 = LA(4);
            						    if ( (synpred26_scma(ctx)) ) 
            						    {
            						        alt18=1;
            						    }
            						    else if ( (ANTLR3_TRUE) ) 
            						    {
            						        alt18=2;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 18;
            						        EXCEPTION->state        = 31;


            						        goto ruleclauseEx;
            						    }
            						}
            					}
            				    break;
            				case 39:
            					{

            						{
            						    int LA18_32 = LA(4);
            						    if ( (synpred26_scma(ctx)) ) 
            						    {
            						        alt18=1;
            						    }
            						    else if ( (ANTLR3_TRUE) ) 
            						    {
            						        alt18=2;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 18;
            						        EXCEPTION->state        = 32;


            						        goto ruleclauseEx;
            						    }
            						}
            					}
            				    break;
            				case 40:
            					{

            						{
            						    int LA18_33 = LA(4);
            						    if ( (synpred26_scma(ctx)) ) 
            						    {
            						        alt18=1;
            						    }
            						    else if ( (ANTLR3_TRUE) ) 
            						    {
            						        alt18=2;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 18;
            						        EXCEPTION->state        = 33;


            						        goto ruleclauseEx;
            						    }
            						}
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return nodeid;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 18;
            				    EXCEPTION->state        = 11;


            				    goto ruleclauseEx;
            				}

            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return nodeid;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 18;
            		    EXCEPTION->state        = 4;


            		    goto ruleclauseEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return nodeid;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 0;


                goto ruleclauseEx;
            }

            switch (alt18) 
            {
        	case 1:
        	    // scma.g:295:3: be= boolean_expression ';'
        	    {
        	        FOLLOWPUSH(FOLLOW_boolean_expression_in_clause912);
        	        be=boolean_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleclauseEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                nodeid = be;
        	                theory->vocabIds.push_back(nodeid);
        	              
        	        }
        	         MATCHT(23, &FOLLOW_23_in_clause921); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleclauseEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }

        	    }
        	    break;
        	case 2:
        	    // scma.g:302:3: '(' be= boolean_expression ')' ';'
        	    {
        	         MATCHT(37, &FOLLOW_37_in_clause929); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleclauseEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        FOLLOWPUSH(FOLLOW_boolean_expression_in_clause933);
        	        be=boolean_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleclauseEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(38, &FOLLOW_38_in_clause935); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleclauseEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                nodeid = be;
        	                theory->vocabIds.push_back(nodeid);
        	              
        	        }
        	         MATCHT(23, &FOLLOW_23_in_clause943); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleclauseEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleclauseEx; /* Prevent compiler warnings */
    ruleclauseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(10, clause_StartIndex); }

    return nodeid;
}
/* $ANTLR end clause */

/** 
 * $ANTLR start boolean_expression
 * scma.g:310:1: boolean_expression returns [int nodeid] : ( 'true' | 'false' | i= IDENTIFIER | '(' t1= term (o= RELATIONAL_OP | '=' ) t2= term ')' | '(' e1= boolean_expression o= BOOLEAN_OP e2= boolean_expression ')' | '(' ( '!' | 'not' ) e= boolean_expression ')' | '(' 'forall' i= IDENTIFIER '.' e= boolean_expression ')' | '(' 'exists' i= IDENTIFIER '.' e= boolean_expression ')' );
 */
static int
boolean_expression(pscmaParser ctx)
{   
    int nodeid = 0;
    ANTLR3_UINT32 boolean_expression_StartIndex;
    pANTLR3_COMMON_TOKEN    i;
    pANTLR3_COMMON_TOKEN    o;
    int t1;
    #undef	RETURN_TYPE_t1
    #define	RETURN_TYPE_t1 int

    int t2;
    #undef	RETURN_TYPE_t2
    #define	RETURN_TYPE_t2 int

    int e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 int

    int e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 int

    int e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e int

    /* Initialize rule variables
     */
    boolean_expression_StartIndex = INDEX();



      string op;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(11)) )
    {

        {
        }


        return nodeid; 
    }
    i       = NULL;
    o       = NULL;
    t1 = 0;
    t2 = 0;
    e1 = 0;
    e2 = 0;
    e = 0;

    {
        {
            //  scma.g:314:1: ( 'true' | 'false' | i= IDENTIFIER | '(' t1= term (o= RELATIONAL_OP | '=' ) t2= term ')' | '(' e1= boolean_expression o= BOOLEAN_OP e2= boolean_expression ')' | '(' ( '!' | 'not' ) e= boolean_expression ')' | '(' 'forall' i= IDENTIFIER '.' e= boolean_expression ')' | '(' 'exists' i= IDENTIFIER '.' e= boolean_expression ')' )
            
            ANTLR3_UINT32 alt20;

            alt20=8;

            switch ( LA(1) ) 
            {
            case 39:
            	{
            		alt20=1;
            	}
                break;
            case 40:
            	{
            		alt20=2;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt20=3;
            	}
                break;
            case 37:
            	{
            		switch ( LA(2) ) 
            		{
            		case 41:
            		case 42:
            			{
            				alt20=6;
            			}
            		    break;
            		case 43:
            			{
            				alt20=7;
            			}
            		    break;
            		case 45:
            			{
            				alt20=8;
            			}
            		    break;
            		case DECIMAL_LITERAL:
            		case 36:
            			{
            				alt20=4;
            			}
            		    break;
            		case 37:
            			{
            				switch ( LA(3) ) 
            				{
            				case 39:
            				case 40:
            				case 41:
            				case 42:
            				case 43:
            				case 45:
            					{
            						alt20=5;
            					}
            				    break;
            				case 36:
            					{

            						{
            						    int LA20_17 = LA(4);
            						    if ( (synpred31_scma(ctx)) ) 
            						    {
            						        alt20=4;
            						    }
            						    else if ( (synpred32_scma(ctx)) ) 
            						    {
            						        alt20=5;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 20;
            						        EXCEPTION->state        = 17;


            						        goto ruleboolean_expressionEx;
            						    }
            						}
            					}
            				    break;
            				case 37:
            					{

            						{
            						    int LA20_18 = LA(4);
            						    if ( (synpred31_scma(ctx)) ) 
            						    {
            						        alt20=4;
            						    }
            						    else if ( (synpred32_scma(ctx)) ) 
            						    {
            						        alt20=5;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 20;
            						        EXCEPTION->state        = 18;


            						        goto ruleboolean_expressionEx;
            						    }
            						}
            					}
            				    break;
            				case DECIMAL_LITERAL:
            					{

            						{
            						    int LA20_19 = LA(4);
            						    if ( (synpred31_scma(ctx)) ) 
            						    {
            						        alt20=4;
            						    }
            						    else if ( (synpred32_scma(ctx)) ) 
            						    {
            						        alt20=5;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 20;
            						        EXCEPTION->state        = 19;


            						        goto ruleboolean_expressionEx;
            						    }
            						}
            					}
            				    break;
            				case IDENTIFIER:
            					{

            						{
            						    int LA20_20 = LA(4);
            						    if ( (synpred31_scma(ctx)) ) 
            						    {
            						        alt20=4;
            						    }
            						    else if ( (synpred32_scma(ctx)) ) 
            						    {
            						        alt20=5;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return nodeid;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 20;
            						        EXCEPTION->state        = 20;


            						        goto ruleboolean_expressionEx;
            						    }
            						}
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return nodeid;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 20;
            				    EXCEPTION->state        = 9;


            				    goto ruleboolean_expressionEx;
            				}

            			}
            		    break;
            		case IDENTIFIER:
            			{
            				switch ( LA(3) ) 
            				{
            				case RELATIONAL_OP:
            				case ADDITION_OP:
            				case PRODUCT_OP:
            				case 22:
            				case 33:
            					{
            						alt20=4;
            					}
            				    break;
            				case BOOLEAN_OP:
            					{
            						alt20=5;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return nodeid;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 20;
            				    EXCEPTION->state        = 11;


            				    goto ruleboolean_expressionEx;
            				}

            			}
            		    break;
            		case 39:
            		case 40:
            			{
            				alt20=5;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return nodeid;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 20;
            		    EXCEPTION->state        = 4;


            		    goto ruleboolean_expressionEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return nodeid;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto ruleboolean_expressionEx;
            }

            switch (alt20) 
            {
        	case 1:
        	    // scma.g:314:3: 'true'
        	    {
        	         MATCHT(39, &FOLLOW_39_in_boolean_expression963); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                       nodeid = theory->handleTrue();
        	                     
        	        }

        	    }
        	    break;
        	case 2:
        	    // scma.g:319:1: 'false'
        	    {
        	         MATCHT(40, &FOLLOW_40_in_boolean_expression980); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                       nodeid = theory->handleFalse();
        	                     
        	        }

        	    }
        	    break;
        	case 3:
        	    // scma.g:324:1: i= IDENTIFIER
        	    {
        	        i = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_boolean_expression998); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                       string name((const char*)(i->getText(i))->chars);
        	                       nodeid = theory->getIdOfUsedVarible(name, SCTheory::SC_VOCAB);
        	                       assert(theory->getNode(nodeid).type == "bool");
        	                     
        	        }

        	    }
        	    break;
        	case 4:
        	    // scma.g:331:1: '(' t1= term (o= RELATIONAL_OP | '=' ) t2= term ')'
        	    {
        	         MATCHT(37, &FOLLOW_37_in_boolean_expression1014); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        FOLLOWPUSH(FOLLOW_term_in_boolean_expression1018);
        	        t1=term(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }

        	        // scma.g:331:13: (o= RELATIONAL_OP | '=' )
        	        {
        	            int alt19=2;
        	            switch ( LA(1) ) 
        	            {
        	            case RELATIONAL_OP:
        	            	{
        	            		alt19=1;
        	            	}
        	                break;
        	            case 22:
        	            	{
        	            		alt19=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return nodeid;
        	                }
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 19;
        	                EXCEPTION->state        = 0;


        	                goto ruleboolean_expressionEx;
        	            }

        	            switch (alt19) 
        	            {
        	        	case 1:
        	        	    // scma.g:331:14: o= RELATIONAL_OP
        	        	    {
        	        	        o = (pANTLR3_COMMON_TOKEN) MATCHT(RELATIONAL_OP, &FOLLOW_RELATIONAL_OP_in_boolean_expression1023); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleboolean_expressionEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return nodeid;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) 
        	        	        {

        	        	                       op = string((const char*)(o->getText(o))->chars);
        	        	                     
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // scma.g:335:9: '='
        	        	    {
        	        	         MATCHT(22, &FOLLOW_22_in_boolean_expression1045); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleboolean_expressionEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return nodeid;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) 
        	        	        {

        	        	                       op = "=";
        	        	                     
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }
        	        FOLLOWPUSH(FOLLOW_term_in_boolean_expression1069);
        	        t2=term(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(38, &FOLLOW_38_in_boolean_expression1071); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                       nodeid = theory->handleTermRelationalTerm(
        	                           op, t1, t2);
        	                     
        	        }

        	    }
        	    break;
        	case 5:
        	    // scma.g:346:1: '(' e1= boolean_expression o= BOOLEAN_OP e2= boolean_expression ')'
        	    {
        	         MATCHT(37, &FOLLOW_37_in_boolean_expression1086); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        FOLLOWPUSH(FOLLOW_boolean_expression_in_boolean_expression1090);
        	        e1=boolean_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        o = (pANTLR3_COMMON_TOKEN) MATCHT(BOOLEAN_OP, &FOLLOW_BOOLEAN_OP_in_boolean_expression1094); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        FOLLOWPUSH(FOLLOW_boolean_expression_in_boolean_expression1098);
        	        e2=boolean_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(38, &FOLLOW_38_in_boolean_expression1100); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                       string op((const char*)(o->getText(o))->chars);
        	                       nodeid = theory->handleBEBoolBE(
        	                           op, e1, e2);
        	                     
        	        }

        	    }
        	    break;
        	case 6:
        	    // scma.g:353:1: '(' ( '!' | 'not' ) e= boolean_expression ')'
        	    {
        	         MATCHT(37, &FOLLOW_37_in_boolean_expression1116); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( ((LA(1) >= 41) && (LA(1) <= 42)) )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return nodeid;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = &FOLLOW_set_in_boolean_expression1118;
        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_boolean_expression1118);    goto ruleboolean_expressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_boolean_expression_in_boolean_expression1126);
        	        e=boolean_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(38, &FOLLOW_38_in_boolean_expression1128); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                       nodeid = theory->handleNot(e);
        	                     
        	        }

        	    }
        	    break;
        	case 7:
        	    // scma.g:358:1: '(' 'forall' i= IDENTIFIER '.' e= boolean_expression ')'
        	    {
        	         MATCHT(37, &FOLLOW_37_in_boolean_expression1144); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(43, &FOLLOW_43_in_boolean_expression1146); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        i = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_boolean_expression1150); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(44, &FOLLOW_44_in_boolean_expression1152); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        FOLLOWPUSH(FOLLOW_boolean_expression_in_boolean_expression1156);
        	        e=boolean_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(38, &FOLLOW_38_in_boolean_expression1158); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                       string name((const char*)(i->getText(i))->chars);
        	                       int varid = theory->getIdOfUsedVarible(name, SCTheory::SC_VOCAB);
        	                       nodeid = theory->handleForall(
        	                           varid, e);
        	                     
        	        }

        	    }
        	    break;
        	case 8:
        	    // scma.g:366:1: '(' 'exists' i= IDENTIFIER '.' e= boolean_expression ')'
        	    {
        	         MATCHT(37, &FOLLOW_37_in_boolean_expression1173); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(45, &FOLLOW_45_in_boolean_expression1175); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        i = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_boolean_expression1179); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(44, &FOLLOW_44_in_boolean_expression1181); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        FOLLOWPUSH(FOLLOW_boolean_expression_in_boolean_expression1185);
        	        e=boolean_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(38, &FOLLOW_38_in_boolean_expression1187); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboolean_expressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                       string name((const char*)(i->getText(i))->chars);
        	                       int varid = theory->getIdOfUsedVarible(name, SCTheory::SC_VOCAB);
        	                       nodeid = theory->handleExists(
        	                           varid, e);
        	                     
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleboolean_expressionEx; /* Prevent compiler warnings */
    ruleboolean_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(11, boolean_expression_StartIndex); }

    return nodeid;
}
/* $ANTLR end boolean_expression */

/** 
 * $ANTLR start term
 * scma.g:375:1: term returns [int nodeid] : a= additionop ;
 */
static int
term(pscmaParser ctx)
{   
    int nodeid = 0;
    ANTLR3_UINT32 term_StartIndex;
    int a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a int

    /* Initialize rule variables
     */
    term_StartIndex = INDEX();


    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(12)) )
    {

        {
        }


        return nodeid; 
    }
    a = 0;

    {
        // scma.g:375:27: (a= additionop )
        // scma.g:376:1: a= additionop
        {
            FOLLOWPUSH(FOLLOW_additionop_in_term1214);
            a=additionop(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletermEx;
            }
            if (HASFAILED())
            {
                return nodeid;
            }
            if ( BACKTRACKING==0 ) 
            {

                  nodeid = a;

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(12, term_StartIndex); }

    return nodeid;
}
/* $ANTLR end term */

/** 
 * $ANTLR start additionop
 * scma.g:383:1: additionop returns [int nodeid] : t1= productop (o= ADDITION_OP t2= productop )? ;
 */
static int
additionop(pscmaParser ctx)
{   
    int nodeid = 0;
    ANTLR3_UINT32 additionop_StartIndex;
    pANTLR3_COMMON_TOKEN    o;
    int t1;
    #undef	RETURN_TYPE_t1
    #define	RETURN_TYPE_t1 int

    int t2;
    #undef	RETURN_TYPE_t2
    #define	RETURN_TYPE_t2 int

    /* Initialize rule variables
     */
    additionop_StartIndex = INDEX();



      int lastnodeid;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(13)) )
    {

        {
        }


        return nodeid; 
    }
    o       = NULL;
    t1 = 0;
    t2 = 0;

    {
        // scma.g:387:1: (t1= productop (o= ADDITION_OP t2= productop )? )
        // scma.g:388:1: t1= productop (o= ADDITION_OP t2= productop )?
        {
            FOLLOWPUSH(FOLLOW_productop_in_additionop1237);
            t1=productop(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleadditionopEx;
            }
            if (HASFAILED())
            {
                return nodeid;
            }
            if ( BACKTRACKING==0 ) 
            {

                          lastnodeid = t1;
                        
            }

            // scma.g:392:1: (o= ADDITION_OP t2= productop )?
            {
                int alt21=2;
                switch ( LA(1) ) 
                {
                    case ADDITION_OP:
                    	{
                    		alt21=1;
                    	}
                        break;
                }

                switch (alt21) 
                {
            	case 1:
            	    // scma.g:392:2: o= ADDITION_OP t2= productop
            	    {
            	        o = (pANTLR3_COMMON_TOKEN) MATCHT(ADDITION_OP, &FOLLOW_ADDITION_OP_in_additionop1253); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadditionopEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return nodeid;
            	        }
            	        FOLLOWPUSH(FOLLOW_productop_in_additionop1257);
            	        t2=productop(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadditionopEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return nodeid;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	                       string op((const char*)(o->getText(o))->chars);
            	                       lastnodeid = theory->handleTermArithTerm(op, lastnodeid, t2);
            	                    
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {

                          nodeid = lastnodeid;
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleadditionopEx; /* Prevent compiler warnings */
    ruleadditionopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(13, additionop_StartIndex); }

    return nodeid;
}
/* $ANTLR end additionop */

/** 
 * $ANTLR start productop
 * scma.g:405:1: productop returns [int nodeid] : t1= unaryop (o= PRODUCT_OP t2= unaryop )* ;
 */
static int
productop(pscmaParser ctx)
{   
    int nodeid = 0;
    ANTLR3_UINT32 productop_StartIndex;
    pANTLR3_COMMON_TOKEN    o;
    int t1;
    #undef	RETURN_TYPE_t1
    #define	RETURN_TYPE_t1 int

    int t2;
    #undef	RETURN_TYPE_t2
    #define	RETURN_TYPE_t2 int

    /* Initialize rule variables
     */
    productop_StartIndex = INDEX();



      int lastnodeid;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(14)) )
    {

        {
        }


        return nodeid; 
    }
    o       = NULL;
    t1 = 0;
    t2 = 0;

    {
        // scma.g:409:1: (t1= unaryop (o= PRODUCT_OP t2= unaryop )* )
        // scma.g:410:1: t1= unaryop (o= PRODUCT_OP t2= unaryop )*
        {
            FOLLOWPUSH(FOLLOW_unaryop_in_productop1301);
            t1=unaryop(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproductopEx;
            }
            if (HASFAILED())
            {
                return nodeid;
            }
            if ( BACKTRACKING==0 ) 
            {

                          lastnodeid = t1;
                        
            }

            // scma.g:414:1: (o= PRODUCT_OP t2= unaryop )*

            for (;;)
            {
                int alt22=2;
                switch ( LA(1) ) 
                {
                case PRODUCT_OP:
                	{
                		alt22=1;
                	}
                    break;

                }

                switch (alt22) 
                {
            	case 1:
            	    // scma.g:414:2: o= PRODUCT_OP t2= unaryop
            	    {
            	        o = (pANTLR3_COMMON_TOKEN) MATCHT(PRODUCT_OP, &FOLLOW_PRODUCT_OP_in_productop1317); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleproductopEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return nodeid;
            	        }
            	        FOLLOWPUSH(FOLLOW_unaryop_in_productop1321);
            	        t2=unaryop(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleproductopEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return nodeid;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	                       string op((const char*)(o->getText(o))->chars);
            	                       lastnodeid = theory->handleTermArithTerm(op, lastnodeid, t2);
            	                    
            	        }

            	    }
            	    break;

            	default:
            	    goto loop22;	/* break out of the loop */
            	    break;
                }
            }
            loop22: ; /* Jump out to here if this rule does not match */

            if ( BACKTRACKING==0 ) 
            {

                          nodeid = lastnodeid;
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleproductopEx; /* Prevent compiler warnings */
    ruleproductopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(14, productop_StartIndex); }

    return nodeid;
}
/* $ANTLR end productop */

/** 
 * $ANTLR start unaryop
 * scma.g:426:1: unaryop returns [int nodeid] : ( '-' a= atom | a= atom );
 */
static int
unaryop(pscmaParser ctx)
{   
    int nodeid = 0;
    ANTLR3_UINT32 unaryop_StartIndex;
    int a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a int

    /* Initialize rule variables
     */
    unaryop_StartIndex = INDEX();


    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(15)) )
    {

        {
        }


        return nodeid; 
    }
    a = 0;

    {
        {
            //  scma.g:426:30: ( '-' a= atom | a= atom )
            
            ANTLR3_UINT32 alt23;

            alt23=2;

            switch ( LA(1) ) 
            {
            case 36:
            	{
            		alt23=1;
            	}
                break;
            case IDENTIFIER:
            case DECIMAL_LITERAL:
            case 37:
            	{
            		alt23=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return nodeid;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 23;
                EXCEPTION->state        = 0;


                goto ruleunaryopEx;
            }

            switch (alt23) 
            {
        	case 1:
        	    // scma.g:427:1: '-' a= atom
        	    {
        	         MATCHT(36, &FOLLOW_36_in_unaryop1359); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryopEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        FOLLOWPUSH(FOLLOW_atom_in_unaryop1363);
        	        a=atom(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryopEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                      nodeid = theory->handleUnaryMinus(a);
        	                    
        	        }

        	    }
        	    break;
        	case 2:
        	    // scma.g:431:3: a= atom
        	    {
        	        FOLLOWPUSH(FOLLOW_atom_in_unaryop1379);
        	        a=atom(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryopEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                      nodeid = a;
        	                    
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleunaryopEx; /* Prevent compiler warnings */
    ruleunaryopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(15, unaryop_StartIndex); }

    return nodeid;
}
/* $ANTLR end unaryop */

/** 
 * $ANTLR start atom
 * scma.g:438:1: atom returns [int nodeid] : ( '(' t= term ')' | d= DECIMAL_LITERAL | i= IDENTIFIER | i= IDENTIFIER '[' t= term ']' );
 */
static int
atom(pscmaParser ctx)
{   
    int nodeid = 0;
    ANTLR3_UINT32 atom_StartIndex;
    pANTLR3_COMMON_TOKEN    d;
    pANTLR3_COMMON_TOKEN    i;
    int t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t int

    /* Initialize rule variables
     */
    atom_StartIndex = INDEX();


    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(16)) )
    {

        {
        }


        return nodeid; 
    }
    d       = NULL;
    i       = NULL;
    t = 0;

    {
        {
            //  scma.g:438:27: ( '(' t= term ')' | d= DECIMAL_LITERAL | i= IDENTIFIER | i= IDENTIFIER '[' t= term ']' )
            
            ANTLR3_UINT32 alt24;

            alt24=4;

            switch ( LA(1) ) 
            {
            case 37:
            	{
            		alt24=1;
            	}
                break;
            case DECIMAL_LITERAL:
            	{
            		alt24=2;
            	}
                break;
            case IDENTIFIER:
            	{
            		switch ( LA(2) ) 
            		{
            		case 33:
            			{
            				alt24=4;
            			}
            		    break;
            		case EOF:
            		case RELATIONAL_OP:
            		case ADDITION_OP:
            		case PRODUCT_OP:
            		case 22:
            		case 34:
            		case 38:
            			{
            				alt24=3;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return nodeid;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 24;
            		    EXCEPTION->state        = 3;


            		    goto ruleatomEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return nodeid;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto ruleatomEx;
            }

            switch (alt24) 
            {
        	case 1:
        	    // scma.g:439:1: '(' t= term ')'
        	    {
        	         MATCHT(37, &FOLLOW_37_in_atom1404); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        FOLLOWPUSH(FOLLOW_term_in_atom1408);
        	        t=term(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(38, &FOLLOW_38_in_atom1410); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                      nodeid = t;
        	                    
        	        }

        	    }
        	    break;
        	case 2:
        	    // scma.g:444:1: d= DECIMAL_LITERAL
        	    {
        	        d = (pANTLR3_COMMON_TOKEN) MATCHT(DECIMAL_LITERAL, &FOLLOW_DECIMAL_LITERAL_in_atom1427); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                      int val = atoi((const char*)(d->getText(d))->chars);
        	                      theory->handleConstantDeclaration(val);
        	                      nodeid = theory->getIdOfUsedConstant(val, SCTheory::SC_VOCAB);
        	                    
        	        }

        	    }
        	    break;
        	case 3:
        	    // scma.g:451:1: i= IDENTIFIER
        	    {
        	        i = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_atom1443); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                       string name((const char*)(i->getText(i))->chars);
        	                       nodeid = theory->getIdOfUsedVarible(name, SCTheory::SC_VOCAB);
        	                       VocabNode & var = theory->getNode(nodeid);
        	                       if (var.type != "int") {
        	                         cout << "SPCHK: warning: used variable '" << var.name << "' of type '" << 
        	                           var.type << "' where an `int' should be used." << endl;
        	                       }
        	                    
        	        }

        	    }
        	    break;
        	case 4:
        	    // scma.g:462:1: i= IDENTIFIER '[' t= term ']'
        	    {
        	        i = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_atom1460); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(33, &FOLLOW_33_in_atom1462); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        FOLLOWPUSH(FOLLOW_term_in_atom1466);
        	        t=term(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	         MATCHT(34, &FOLLOW_34_in_atom1468); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return nodeid;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                       string name((const char*)(i->getText(i))->chars);
        	                       unsigned int arrayid = theory->getIdOfUsedVarible(name, SCTheory::SC_VOCAB);
        	                       VocabNode & var = theory->getNode(arrayid);
        	                       if (! (var.type == "array" || var.type =="barray" )) {
        	                         cout << "SPCHK: warning: used variable '" << var.name << "' of type '" << 
        	                           var.type << "' where an `array' or a `barray' should be used." << endl;
        	                       }
        	                       nodeid = theory->handleArrayAccess(arrayid, t);
        	                    
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleatomEx; /* Prevent compiler warnings */
    ruleatomEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(16, atom_StartIndex); }

    return nodeid;
}
/* $ANTLR end atom */

/** 
 * $ANTLR start operation
 * scma.g:475:1: operation : ( 'bound' | 'index' | 'arithmetic' | 'relational' | RELATIONAL_OP | '=' | ADDITION_OP | PRODUCT_OP | '[]' );
 */
static scmaParser_operation_return
operation(pscmaParser ctx)
{   
    scmaParser_operation_return retval;
    ANTLR3_UINT32 operation_StartIndex;
    /* Initialize rule variables
     */
    operation_StartIndex = INDEX();


    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(17)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    retval.start = LT(1); retval.stop = retval.start;

    {
        // scma.g:475:10: ( 'bound' | 'index' | 'arithmetic' | 'relational' | RELATIONAL_OP | '=' | ADDITION_OP | PRODUCT_OP | '[]' )
        // scma.g:
        {
            if ( LA(1) == RELATIONAL_OP || ((LA(1) >= ADDITION_OP) && (LA(1) <= PRODUCT_OP)) || LA(1) == 22 || LA(1) == 32 || ((LA(1) >= 46) && (LA(1) <= 49)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_operation0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_operation0);    goto ruleoperationEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleoperationEx; /* Prevent compiler warnings */
    ruleoperationEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(17, operation_StartIndex); }

    return retval;
}
/* $ANTLR end operation */

// $ANTLR start synpred18_scma
static void synpred18_scma_fragment(pscmaParser ctx ) 
{
	int s;
	#undef	RETURN_TYPE_s
	#define	RETURN_TYPE_s int

	s = 0;

    // scma.g:192:3: ( 'int' '[' s= constant ']' )
    // scma.g:192:3: 'int' '[' s= constant ']'
    {
         MATCHT(31, &FOLLOW_31_in_synpred18_scma572); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred18_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(33, &FOLLOW_33_in_synpred18_scma574); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred18_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_constant_in_synpred18_scma578);
        s=constant(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred18_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(34, &FOLLOW_34_in_synpred18_scma582); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred18_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred18_scmaEx; /* Prevent compiler warnings */
rulesynpred18_scmaEx: ;

}
// $ANTLR end synpred18_scma

// $ANTLR start synpred21_scma
static void synpred21_scma_fragment(pscmaParser ctx ) 
{
	int s;
	#undef	RETURN_TYPE_s
	#define	RETURN_TYPE_s int

	s = 0;

    // scma.g:200:3: ( 'boolean' '[' (s= constant )? ']' )
    // scma.g:200:3: 'boolean' '[' (s= constant )? ']'
    {
         MATCHT(35, &FOLLOW_35_in_synpred21_scma612); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred21_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(33, &FOLLOW_33_in_synpred21_scma614); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred21_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // scma.g:200:17: (s= constant )?
        {
            int alt28=2;
            switch ( LA(1) ) 
            {
                case DECIMAL_LITERAL:
                case 36:
                	{
                		alt28=1;
                	}
                    break;
            }

            switch (alt28) 
            {
        	case 1:
        	    // scma.g:200:18: s= constant
        	    {
        	        FOLLOWPUSH(FOLLOW_constant_in_synpred21_scma619);
        	        s=constant(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesynpred21_scmaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
         MATCHT(34, &FOLLOW_34_in_synpred21_scma625); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred21_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred21_scmaEx; /* Prevent compiler warnings */
rulesynpred21_scmaEx: ;

}
// $ANTLR end synpred21_scma

// $ANTLR start synpred22_scma
static void synpred22_scma_fragment(pscmaParser ctx ) 
{
	int s;
	#undef	RETURN_TYPE_s
	#define	RETURN_TYPE_s int

	int q;
	#undef	RETURN_TYPE_q
	#define	RETURN_TYPE_q int

	s = 0;
	q = 0;

    // scma.g:204:3: ( 'int' '[' s= constant ']' '[' q= constant ']' )
    // scma.g:204:3: 'int' '[' s= constant ']' '[' q= constant ']'
    {
         MATCHT(31, &FOLLOW_31_in_synpred22_scma640); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred22_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(33, &FOLLOW_33_in_synpred22_scma643); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred22_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_constant_in_synpred22_scma647);
        s=constant(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred22_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(34, &FOLLOW_34_in_synpred22_scma649); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred22_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(33, &FOLLOW_33_in_synpred22_scma651); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred22_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_constant_in_synpred22_scma655);
        q=constant(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred22_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(34, &FOLLOW_34_in_synpred22_scma657); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred22_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred22_scmaEx; /* Prevent compiler warnings */
rulesynpred22_scmaEx: ;

}
// $ANTLR end synpred22_scma

// $ANTLR start synpred26_scma
static void synpred26_scma_fragment(pscmaParser ctx ) 
{
	int be;
	#undef	RETURN_TYPE_be
	#define	RETURN_TYPE_be int

	be = 0;

    // scma.g:295:3: (be= boolean_expression ';' )
    // scma.g:295:3: be= boolean_expression ';'
    {
        FOLLOWPUSH(FOLLOW_boolean_expression_in_synpred26_scma912);
        be=boolean_expression(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred26_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(23, &FOLLOW_23_in_synpred26_scma921); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred26_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred26_scmaEx; /* Prevent compiler warnings */
rulesynpred26_scmaEx: ;

}
// $ANTLR end synpred26_scma

// $ANTLR start synpred31_scma
static void synpred31_scma_fragment(pscmaParser ctx ) 
{
	pANTLR3_COMMON_TOKEN    o;
	int t1;
	#undef	RETURN_TYPE_t1
	#define	RETURN_TYPE_t1 int

	int t2;
	#undef	RETURN_TYPE_t2
	#define	RETURN_TYPE_t2 int

	o       = NULL;
	t1 = 0;
	t2 = 0;

    // scma.g:331:1: ( '(' t1= term (o= RELATIONAL_OP | '=' ) t2= term ')' )
    // scma.g:331:1: '(' t1= term (o= RELATIONAL_OP | '=' ) t2= term ')'
    {
         MATCHT(37, &FOLLOW_37_in_synpred31_scma1014); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred31_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_term_in_synpred31_scma1018);
        t1=term(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred31_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // scma.g:331:13: (o= RELATIONAL_OP | '=' )
        {
            int alt29=2;
            switch ( LA(1) ) 
            {
            case RELATIONAL_OP:
            	{
            		alt29=1;
            	}
                break;
            case 22:
            	{
            		alt29=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 29;
                EXCEPTION->state        = 0;


                goto rulesynpred31_scmaEx;
            }

            switch (alt29) 
            {
        	case 1:
        	    // scma.g:331:14: o= RELATIONAL_OP
        	    {
        	        o = (pANTLR3_COMMON_TOKEN) MATCHT(RELATIONAL_OP, &FOLLOW_RELATIONAL_OP_in_synpred31_scma1023); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesynpred31_scmaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // scma.g:335:9: '='
        	    {
        	         MATCHT(22, &FOLLOW_22_in_synpred31_scma1045); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesynpred31_scmaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
        FOLLOWPUSH(FOLLOW_term_in_synpred31_scma1069);
        t2=term(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred31_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(38, &FOLLOW_38_in_synpred31_scma1071); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred31_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred31_scmaEx; /* Prevent compiler warnings */
rulesynpred31_scmaEx: ;

}
// $ANTLR end synpred31_scma

// $ANTLR start synpred32_scma
static void synpred32_scma_fragment(pscmaParser ctx ) 
{
	pANTLR3_COMMON_TOKEN    o;
	int e1;
	#undef	RETURN_TYPE_e1
	#define	RETURN_TYPE_e1 int

	int e2;
	#undef	RETURN_TYPE_e2
	#define	RETURN_TYPE_e2 int

	o       = NULL;
	e1 = 0;
	e2 = 0;

    // scma.g:346:1: ( '(' e1= boolean_expression o= BOOLEAN_OP e2= boolean_expression ')' )
    // scma.g:346:1: '(' e1= boolean_expression o= BOOLEAN_OP e2= boolean_expression ')'
    {
         MATCHT(37, &FOLLOW_37_in_synpred32_scma1086); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred32_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_boolean_expression_in_synpred32_scma1090);
        e1=boolean_expression(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred32_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        o = (pANTLR3_COMMON_TOKEN) MATCHT(BOOLEAN_OP, &FOLLOW_BOOLEAN_OP_in_synpred32_scma1094); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred32_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_boolean_expression_in_synpred32_scma1098);
        e2=boolean_expression(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred32_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(38, &FOLLOW_38_in_synpred32_scma1100); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred32_scmaEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred32_scmaEx; /* Prevent compiler warnings */
rulesynpred32_scmaEx: ;

}
// $ANTLR end synpred32_scma
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred32_scma(pscmaParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred32_scma_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred31_scma(pscmaParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred31_scma_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred22_scma(pscmaParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred22_scma_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred21_scma(pscmaParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred21_scma_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred18_scma(pscmaParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred18_scma_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred26_scma(pscmaParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred26_scma_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
