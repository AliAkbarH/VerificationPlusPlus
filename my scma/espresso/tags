ABSENT	signature.h	13
ACTIVE	espresso.h	116
BB	black_white.c	31
BPI	espresso.h	22
BPI	espresso.h	50
BW_TIME	espresso.h	379
COMPL	espresso.h	337
COMPL_TIME	espresso.h	359
CONSTRAINTS_type	espresso.h	329
COVER	essentiality.c	57
COVERED	espresso.h	118
CUBELISTSIZE	espresso.h	/^#define CUBELISTSIZE(T)         (((pcube *) T[1] -/
CUBE_TEMP	espresso.h	463
D	espresso.h	302
DASH	espresso.h	404
DISJOINT	espresso.h	503
DISJOINT	espresso.h	506
DISJOINT	espresso.h	508
DR_type	espresso.h	333
D_type	espresso.h	324
EQNTOTT_type	espresso.h	327
ESSEN	espresso.h	338
ESSEN_TIME	espresso.h	361
ETRAUX_TIME	espresso.h	376
ETR_TIME	espresso.h	375
EVEN_MASK	signature.h	3
EVEN_MASK	signature.h	6
EXACT	espresso.h	347
EXEC	espresso.h	/^#define EXEC(fct, name, S)\\$/
EXECUTE	espresso.h	/^#define EXECUTE(fct,i,S,cost)\\$/
EXEC_S	espresso.h	/^#define EXEC_S(fct, name, S)\\$/
EXPAND	espresso.h	339
EXPAND1	espresso.h	340
EXPAND_TIME	espresso.h	362
F	espresso.h	302
FALSE	espresso.h	241
FCC_TIME	espresso.h	374
FDR_type	espresso.h	334
FD_type	espresso.h	331
FR_type	espresso.h	332
F_type	espresso.h	323
Fmin	cvrm.c	392
GASP	espresso.h	341
GETINPUT	espresso.h	/^#define GETINPUT(c, pos)\\$/
GETOUTPUT	espresso.h	/^#define GETOUTPUT(c, pos)\\$/
GETSET	espresso.h	/^#define GETSET(family, index)   ((family)->data + /
GEXPAND_TIME	espresso.h	365
GIRRED_TIME	espresso.h	366
GREDUCE_TIME	espresso.h	367
Gcube	map.c	3
Gminterm	map.c	4
IN	espresso.h	318
INLABEL	espresso.h	/^#define INLABEL(var)    PLA->label[cube.first_part/
INLINEset_and	espresso.h	/^#define INLINEset_and(r, a, b)		(void) set_and(r, /
INLINEset_and	espresso.h	/^#define INLINEset_and(r, a, b)\\$/
INLINEset_clear	espresso.h	/^#define INLINEset_clear(r, size)	(void) set_clear(/
INLINEset_clear	espresso.h	/^#define INLINEset_clear(r, size)\\$/
INLINEset_copy	espresso.h	/^#define INLINEset_copy(r, a)		(void) set_copy(r,a)/
INLINEset_copy	espresso.h	/^#define INLINEset_copy(r, a)\\$/
INLINEset_diff	espresso.h	/^#define INLINEset_diff(r, a, b)		(void) set_diff(r/
INLINEset_diff	espresso.h	/^#define INLINEset_diff(r, a, b)\\$/
INLINEset_fill	espresso.h	/^#define INLINEset_fill(r, size)		(void) set_fill(r/
INLINEset_fill	espresso.h	/^#define INLINEset_fill(r, size)\\$/
INLINEset_merge	espresso.h	/^#define INLINEset_merge(r, a, b, mask)	(void) set_/
INLINEset_merge	espresso.h	/^#define INLINEset_merge(r, a, b, mask)\\$/
INLINEset_ndiff	espresso.h	/^#define INLINEset_ndiff(r, a, b, f)	(void) set_ndi/
INLINEset_ndiff	espresso.h	/^#define INLINEset_ndiff(r, a, b, fullset)\\$/
INLINEset_or	espresso.h	/^#define INLINEset_or(r, a, b)		(void) set_or(r, a,/
INLINEset_or	espresso.h	/^#define INLINEset_or(r, a, b)\\$/
INLINEset_xnor	espresso.h	/^#define INLINEset_xnor(r, a, b, f)	(void) set_xnor/
INLINEset_xnor	espresso.h	/^#define INLINEset_xnor(r, a, b, f)	(void) set_xnor/
INLINEset_xnor	espresso.h	/^#define INLINEset_xnor(r, a, b, fullset)\\$/
INLINEset_xor	espresso.h	/^#define INLINEset_xor(r, a, b)		(void) set_xor(r, /
INLINEset_xor	espresso.h	/^#define INLINEset_xor(r, a, b)		(void) set_xor(r, /
INLINEset_xor	espresso.h	/^#define INLINEset_xor(r, a, b)\\$/
INLINEsetp_disjoint	espresso.h	/^#define INLINEsetp_disjoint(a, b, when_false)	\\$/
INLINEsetp_disjoint	espresso.h	/^#define INLINEsetp_disjoint(a, b, when_false)\\$/
INLINEsetp_equal	espresso.h	/^#define INLINEsetp_equal(a, b, when_false)	\\$/
INLINEsetp_equal	espresso.h	/^#define INLINEsetp_equal(a, b, when_false)\\$/
INLINEsetp_implies	espresso.h	/^#define INLINEsetp_implies(a, b, when_false)	\\$/
INLINEsetp_implies	espresso.h	/^#define INLINEsetp_implies(a, b, when_false)\\$/
INOUT	espresso.h	320
IRRED	espresso.h	342
IRRED1	espresso.h	351
IRRED_TIME	espresso.h	363
KEY_ESPRESSO	main.h	2
KEY_MANY_ESPRESSO	main.h	8
KEY_PLA_verify	main.h	2
KEY_check	main.h	2
KEY_contain	main.h	2
KEY_d1merge	main.h	2
KEY_d1merge_in	main.h	9
KEY_disjoint	main.h	3
KEY_dsharp	main.h	3
KEY_echo	main.h	3
KEY_equiv	main.h	8
KEY_essen	main.h	3
KEY_exact	main.h	3
KEY_expand	main.h	3
KEY_fsm	main.h	9
KEY_gasp	main.h	4
KEY_intersect	main.h	4
KEY_irred	main.h	4
KEY_lexsort	main.h	4
KEY_make_sparse	main.h	4
KEY_map	main.h	5
KEY_mapdc	main.h	5
KEY_minterms	main.h	5
KEY_opo	main.h	5
KEY_opoall	main.h	5
KEY_pair	main.h	6
KEY_pairall	main.h	6
KEY_primes	main.h	6
KEY_qm	main.h	6
KEY_reduce	main.h	6
KEY_separate	main.h	9
KEY_sharp	main.h	6
KEY_signature	main.h	9
KEY_simplify	main.h	7
KEY_so	main.h	7
KEY_so_both	main.h	7
KEY_stats	main.h	7
KEY_super_gasp	main.h	7
KEY_taut	main.h	7
KEY_test	main.h	8
KEY_union	main.h	8
KEY_unknown	main.h	10
KEY_verify	main.h	8
KEY_xor	main.h	9
KISS_type	espresso.h	328
LOGBPI	espresso.h	54
LOGBPI	espresso.h	56
LOOP	espresso.h	/^#define LOOP(set)               (set[0] & 0x03ff)$/
LOOPCOPY	espresso.h	/^#define LOOPCOPY(set)           LOOP(set)$/
LOOPCOPY	espresso.h	/^#define LOOPCOPY(set)           (LOOP(set) + 1)$/
LOOPINIT	espresso.h	/^#define LOOPINIT(size)		((size <= BPI) ? 1 : WHICH/
MAGIC	sharp.c	202
MAGIC	unate.c	291
MAYBE	espresso.h	243
MINCOV	espresso.h	348
MINCOV1	espresso.h	349
MINCOV_TIME	espresso.h	369
MV_REDUCE_TIME	espresso.h	370
Mmain	main.c	/^main(argc, argv)$/
NEGATIVE	signature.h	10
NELEM	espresso.h	/^#define NELEM(set)		(BPI * LOOP(set))$/
NEW	expand.c	469
NONESSEN	espresso.h	115
NO_INLINE	espresso.h	13
NO_INLINE	espresso.h	21
NO_LIFTING	compl.c	23
NUMINPUTS	espresso.h	382
NUMOUTPUTS	espresso.h	383
NullS	getopt.c	7
ODD_MASK	signature.h	2
ODD_MASK	signature.h	5
ONE	espresso.h	405
ONSET_TIME	espresso.h	360
OUT	espresso.h	319
OUTLABEL	espresso.h	/^#define OUTLABEL(pos)   PLA->label[cube.first_part/
PLA_labels	cvrin.c	/^PLA_labels(PLA)$/
PLA_permute	verify.c	/^PLA_permute(PLA1, PLA2)$/
PLA_summary	cvrin.c	/^void PLA_summary(PLA)$/
PLA_verify	verify.c	/^bool PLA_verify(PLA1, PLA2)$/
PLEASURE_type	espresso.h	326
POSITIVE	signature.h	9
POSITIVE_PHASE	espresso.h	/^#define POSITIVE_PHASE(pos)\\$/
POW2	opo.c	/^#define POW2(x)		(1 << (x))$/
POWER2	map.c	/^#define POWER2(n) (1 << n)$/
PRESENT	signature.h	12
PRIME	espresso.h	114
PRIMES_TIME	espresso.h	368
PUTINPUT	espresso.h	/^#define PUTINPUT(c, pos, value)\\$/
PUTLOOP	espresso.h	/^#define PUTLOOP(set, i)         (set[0] &= ~0x03ff/
PUTOUTPUT	espresso.h	/^#define PUTOUTPUT(c, pos, value)\\$/
PUTSIZE	espresso.h	/^#define PUTSIZE(set, size)      (set[0] &= 0xffff,/
PUTSIZE	espresso.h	/^#define PUTSIZE(set, size)      ((set[LOOP(set)+1]/
R	espresso.h	302
RAISED	signature.h	15
RAISE_IN_TIME	espresso.h	371
READ_TIME	espresso.h	358
REDUCE	espresso.h	343
REDUCE1	espresso.h	344
REDUCE_TIME	espresso.h	364
REDUND	espresso.h	117
RELESSEN	espresso.h	119
RESET	espresso.h	/^#define RESET(set, flag)        (set[0] &= ~ (flag/
R_type	espresso.h	325
Rp_current	irred.c	8
SET	espresso.h	/^#define SET(set, flag)          (set[0] |= (flag))/
SET_SIZE	espresso.h	/^#define SET_SIZE(size)          ((size) <= BPI ? 2/
SET_SIZE	espresso.h	/^#define SET_SIZE(size)          ((size) <= BPI ? 3/
SHARP	espresso.h	350
SIGMA_TIME	espresso.h	377
SIZE	espresso.h	/^#define SIZE(set)               (set[0] >> 16)$/
SIZE	espresso.h	/^#define SIZE(set)               (set[LOOP(set)+1])/
SPARSE	espresso.h	345
SPARSE_H	sparse.h	2
SYMBOLIC_CONSTRAINTS_type	espresso.h	330
S_EXECUTE	espresso.h	/^#define S_EXECUTE(fct,i)\\$/
TAUT	espresso.h	346
TESTP	espresso.h	/^#define TESTP(set, flag)        (set[0] & (flag))$/
TIME_COUNT	espresso.h	357
TRUE	espresso.h	242
TWO	espresso.h	403
UCOMP_TIME	espresso.h	378
USE_COMPL_LIFT	compl.c	20
USE_COMPL_LIFT_ONSET	compl.c	21
USE_COMPL_LIFT_ONSET_COMPLEX	compl.c	22
USE_GIMPEL	mincov.c	7
USE_INDEP_SET	mincov.c	8
VAR	essentiality.c	38
VERIFY_TIME	espresso.h	372
VERSION	espresso.h	353
WEIGHT	mincov_int.h	/^#define WEIGHT(weight, col)	(weight == NIL(int) ? /
WHICH_BIT	espresso.h	/^#define WHICH_BIT(element)      ((element) & (BPI-/
WHICH_WORD	espresso.h	/^#define WHICH_WORD(element)     (((element) >> LOG/
WRITE_TIME	espresso.h	373
ZERO	espresso.h	406
abs_covered	unate.c	/^abs_covered(A, pick)$/
abs_covered_many	unate.c	/^abs_covered_many(A, pick_set)$/
abs_select_restricted	unate.c	/^abs_select_restricted(A, restrict)$/
active_count	espresso.h	68
all_primes	expand.c	/^pcover all_primes(F, R)$/
alloc_list	black_white.c	/^alloc_list(size)$/
alloc_stack	black_white.c	/^alloc_stack(size)$/
and_with_cofactor	primes.c	/^and_with_cofactor(A, cof)$/
ascend	setc.c	/^int ascend(a, b)$/
ascending	essentiality.c	/^ascending(p1,p2)$/
aux_etr_order	essentiality.c	/^aux_etr_order(F,E,R,c,d)$/
backward	black_white.c	27
backward_compatibility_hack	main.c	/^backward_compatibility_hack(argc, argv, option, ou/
backward_link	black_white.c	26
best	espresso.h	494
best_D	pair.c	356
best_F	pair.c	356
best_R	pair.c	356
best_cost	pair.c	351
best_pair	pair.c	353
best_phase	pair.c	354
binary_mask	espresso.h	474
binate_count	essentiality.c	45
binate_list	essentiality.c	43
binate_split_select	cofactor.c	/^int binate_split_select(T, cleft, cright, debug_fl/
bit_count	globals.c	58
bit_index	set.c	/^int bit_index(a)$/
black_head	black_white.c	25
black_tail	black_white.c	25
black_white	black_white.c	/^black_white()$/
bool	espresso.h	240
build_intersection_matrix	indep.c	/^build_intersection_matrix(A)$/
c_free_count	essentiality.c	25
c_free_list	essentiality.c	24
cactive	setc.c	/^int cactive(a)$/
capacity	espresso.h	66
cb1_dsharp	sharp.c	/^pcover cb1_dsharp(T, c)$/
cb_consensus	essen.c	/^pcover cb_consensus(T, c)$/
cb_consensus_dist0	essen.c	/^pcover cb_consensus_dist0(R, p, c)$/
cb_dsharp	sharp.c	/^pcover cb_dsharp(c, T)$/
cb_recur_sharp	sharp.c	/^pcover cb_recur_sharp(c, T, first, last, level)$/
cb_sharp	sharp.c	/^pcover cb_sharp(c, T)$/
cb_unravel	cvrm.c	/^static void cb_unravel(c, start, end, startbase, B/
ccommon	setc.c	/^bool ccommon(a, b, cof)$/
cdata	globals.c	56
cdata_struct	espresso.h	487
cdist	setc.c	/^int cdist(a, b)$/
cdist0	setc.c	/^bool cdist0(a, b)$/
cdist01	setc.c	/^int cdist01(a, b)$/
check_arg	main.c	/^bool check_arg(argc, argv, s)$/
check_consistency	verify.c	/^bool check_consistency(PLA)$/
check_equiv	equiv.c	/^int check_equiv(f1, f2)$/
cleanup	signature.c	/^cleanup()$/
clear	black_white.c	/^clear()$/
cnt	espresso.h	269
cof_output	cvrm.c	/^pcover cof_output(T, i)$/
cofactor	cofactor.c	/^pcube *cofactor(T, c)$/
col_num	sparse.h	19
col_num	sparse.h	47
cols	sparse.h	64
cols_size	sparse.h	65
comp_count	mincov_int.h	14
compl_cube	compl.c	/^pcover compl_cube(p)$/
compl_d1merge	compl.c	/^void compl_d1merge(L1, R1)$/
compl_lift	compl.c	/^void compl_lift(A1, B1, bcube, var)$/
compl_lift_onset	compl.c	/^void compl_lift_onset(A1, T, bcube, var)$/
compl_lift_onset_complex	compl.c	/^void compl_lift_onset_complex(A1, T, var)$/
compl_merge	compl.c	/^pcover compl_merge(T1, L, R, cl, cr, var, lifting)/
compl_special_cases	compl.c	/^bool compl_special_cases(T, Tbar)$/
complement	compl.c	/^pcover complement(T)$/
component	mincov_int.h	13
consensus	setc.c	/^void consensus(r, a, b)$/
copy_cost	cvrmisc.c	/^void copy_cost(s, d)$/
copy_row	part.c	/^copy_row(A, prow)$/
cost	mincov_int.h	27
cost_array	pair.c	352
cost_struct	espresso.h	257
count	espresso.h	67
count_ones	espresso.h	/^#define count_ones(v)\\$/
count_ones	espresso.h	/^#define count_ones(v)   (bit_count[v & 255] + bit_/
cover_cost	cvrmisc.c	/^void cover_cost(F, cost)$/
cprint	cvrout.c	/^void cprint(T)$/
cube	globals.c	55
cube1list	cofactor.c	/^pcube *cube1list(A)$/
cube2list	cofactor.c	/^pcube *cube2list(A, B)$/
cube3list	cofactor.c	/^pcube *cube3list(A, B, C)$/
cube_is_covered	irred.c	/^cube_is_covered(T, c)$/
cube_setup	cubestr.c	/^void cube_setup()$/
cube_struct	espresso.h	465
cubelist_partition	cvrm.c	/^int cubelist_partition(T, A, B, comp_debug)$/
cubes	espresso.h	258
cubeunlist	cofactor.c	/^pcover cubeunlist(A1)$/
cv_dsharp	sharp.c	/^pcover cv_dsharp(A, B)$/
cv_intersect	sharp.c	/^pcover cv_intersect(A, B)$/
cv_sharp	sharp.c	/^pcover cv_sharp(A, B)$/
d1_order	setc.c	/^int d1_order(a, b)$/
d1_rm_equal	contain.c	/^int d1_rm_equal(A1, compare)$/
d1merge	contain.c	/^pset_family d1merge(A, var)$/
data	espresso.h	69
debug	globals.c	7
debug	mincov_int.h	9
debug1_print	cvrout.c	/^void debug1_print(T, name, num)$/
debug_print	cvrout.c	/^void debug_print(T, name, level)$/
debug_table	main.h	83
delete	black_white.c	/^delete(element)$/
delete_arg	main.c	/^delete_arg(argc, argv, num)$/
delvar	pair.c	/^pcover delvar(A, paired)$/
desc1	setc.c	/^int desc1(a, b)$/
descend	setc.c	/^int descend(a, b)$/
disassemble_fsm	hack.c	/^disassemble_fsm(PLA, verbose_mode)$/
dist_merge	contain.c	/^pset_family dist_merge(A, mask)$/
dll_unlink	sparse_int.h	/^#define dll_unlink(p, first, last, next, prev, cou/
do_minimize	exact.c	/^do_minimize(F, D, R, exact_cover, weighted)$/
do_sm_minimum_cover	sminterf.c	/^do_sm_minimum_cover(A)$/
dsharp	sharp.c	/^pcover dsharp(a, b)$/
dump_irredundant	exact.c	/^dump_irredundant(E, Rt, Rp, table)$/
echo_comments	globals.c	13
echo_unknown_commands	globals.c	14
elim_lowering	expand.c	/^void elim_lowering(BB, CC, RAISE, FREESET)$/
emptyset	espresso.h	479
eqn_output	cvrout.c	/^void eqn_output(PLA)$/
equal	espresso.h	/^#define equal(a,b)      (strcmp(a,b) == 0)$/
esp_opt_table	main.h	101
espresso	espresso.c	/^pcover espresso(F, D1, R)$/
essen_cube	essen.c	/^bool essen_cube(F, D, c)$/
essen_parts	expand.c	/^void essen_parts(BB, CC, RAISE, FREESET)$/
essen_raising	expand.c	/^void essen_raising(BB, RAISE, FREESET)$/
essential	essen.c	/^pcover essential(Fp, Dp)$/
etr_order	essentiality.c	/^etr_order(F,E,R,c,d)$/
exact_minimum_cover	unate.c	/^pset_family exact_minimum_cover(T)$/
expand	expand.c	/^pcover expand(F, R, nonsparse)$/
expand1	expand.c	/^void expand1(BB, CC, RAISE, FREESET, OVEREXPANDED_/
expand1_gasp	gasp.c	/^void expand1_gasp(F, D, R, Foriginal, c1index, G)$/
expand_gasp	gasp.c	/^pcover expand_gasp(F, D, R, Foriginal)$/
explode	map.c	/^void explode(var, z)$/
fail	mincov.c	/^#define fail(why) {\\$/
fatal	cvrmisc.c	/^void fatal(s)$/
fcube_is_covered	irred.c	/^fcube_is_covered(T, c, table)$/
feasibly_covered	expand.c	/^bool feasibly_covered(BB, c, RAISE, new_lower)$/
filename	globals.c	28
filename	espresso.h	303
find_all_primes	expand.c	/^pcover find_all_primes(BB, RAISE, FREESET)$/
find_best_cost	pair.c	/^int find_best_cost(pair)$/
find_canonical_cover	canonical.c	/^find_canonical_cover(F1,D,R)$/
find_covers	opo.c	/^pset_family find_covers(F, D, select, n)$/
find_dc_inputs	hack.c	/^find_dc_inputs(PLA, list, base, maxval, newF, newD/
find_equiv_outputs	equiv.c	/^find_equiv_outputs(PLA)$/
find_inputs	hack.c	/^find_inputs(A, PLA, list, base, value, newF, newD)/
find_optimal_pairing	pair.c	/^void find_optimal_pairing(PLA, strategy)$/
find_pairing_cost	pair.c	/^int **find_pairing_cost(PLA, strategy)$/
find_phase	opo.c	/^pcube find_phase(PLA, first_output, phase1)$/
first_col	sparse.h	35
first_col	sparse.h	69
first_part	espresso.h	469
first_row	sparse.h	50
first_row	sparse.h	66
first_word	espresso.h	472
flag	sparse.h	34
flag	sparse.h	49
fmt_cost	cvrmisc.c	/^char *fmt_cost(cost)$/
fmt_cube	cvrout.c	/^char *fmt_cube(c, out_map, s)$/
force_irredundant	globals.c	15
force_lower	setc.c	/^pset force_lower(xlower, a, b)$/
foreach_active_set	espresso.h	/^#define foreach_active_set(R, last, p)\\$/
foreach_output_function	cvrm.c	/^foreach_output_function(PLA, func, func1)$/
foreach_remaining_set	espresso.h	/^#define foreach_remaining_set(R, last, pfirst, p)\\/
foreach_set	espresso.h	/^#define foreach_set(R, last, p)\\$/
foreach_set_element	espresso.h	/^#define foreach_set_element(p, i, val, base) 		\\$/
foreachi_active_set	espresso.h	/^#define foreachi_active_set(R, i, p)\\$/
foreachi_set	espresso.h	/^#define foreachi_set(R, i, p)\\$/
form_bitvector	hack.c	/^form_bitvector(p, base, value, list)$/
form_cover_table	opo.c	/^pset_family form_cover_table(F, D, select, f, fbar/
forward	black_white.c	27
forward_link	black_white.c	26
fpr_header	cvrout.c	/^void fpr_header(fp, PLA, output_type)$/
fprint_pla	cvrout.c	/^void fprint_pla(fp, PLA, output_type)$/
free_PLA	cvrin.c	/^void free_PLA(PLA)$/
free_bw	black_white.c	/^free_bw()$/
free_count	essentiality.c	37
free_cover	espresso.h	/^#define free_cover(r)           sf_free(r)$/
free_cube	espresso.h	/^#define free_cube(r)            set_free(r)$/
free_cubelist	espresso.h	/^#define free_cubelist(T)        FREE(T[0]); FREE(T/
free_list	black_white.c	/^free_list()$/
free_stack	black_white.c	/^free_stack()$/
fsm_simplify	hack.c	/^static pcover fsm_simplify(F)$/
ftaut_special_cases	irred.c	/^ftaut_special_cases(T, table)$/
ftautology	irred.c	/^ftautology(T, table)$/
full_row	setc.c	/^bool full_row(p, cof)$/
fullset	espresso.h	478
generate_all_pairs	pair.c	/^generate_all_pairs(pair, n, candidate, action)$/
generate_primes	signature.c	/^generate_primes(F,R)$/
getPLA	main.c	/^getPLA(opt, argc, argv, option, PLA, out_type)$/
get_mins	essentiality.c	/^get_mins(c)$/
get_next_variable	black_white.c	/^get_next_variable(pv,pphase,R)$/
get_sigma	sigma.c	/^get_sigma(R,c)$/
get_word	cvrin.c	/^char *get_word(fp, word)$/
getopt	getopt.c	/^int getopt(argc, argv, optstring)$/
gimpel	mincov_int.h	16
gimpel_count	mincov_int.h	15
gimpel_reduce	gimpel.c	/^gimpel_reduce(A, select, weight, lb, bound, depth,/
global_PLA	pair.c	355
greedy_best_cost	pair.c	/^int greedy_best_cost(cost_array_local, pair_p)$/
in	espresso.h	259
init_list	black_white.c	/^init_list(size)$/
init_runtime	main.c	/^init_runtime()$/
inmask	espresso.h	480
input_type	main.c	20
insert	black_white.c	/^insert(element)$/
intcpy	set.c	/^static int intcpy(d, s, n)$/
inword	espresso.h	481
irred_derive_table	irred.c	/^irred_derive_table(D, E, Rp)$/
irred_gasp	gasp.c	/^pcover irred_gasp(F, D, G)$/
irred_split_cover	irred.c	/^irred_split_cover(F, D, E, Rt, Rp)$/
irredundant	irred.c	/^irredundant(F, D)$/
is_in_set	espresso.h	/^#define is_in_set(set, e)       (set[WHICH_WORD(e)/
is_unate	espresso.h	491
key	espresso.h	452
key	main.h	16
keys	main.h	1
kiss	globals.c	17
kiss_output	cvrout.c	/^kiss_output(fp, PLA)$/
kiss_print_cube	cvrout.c	/^kiss_print_cube(fp, PLA, p, out_string)$/
label	espresso.h	285
label	espresso.h	307
label_index	cvrin.c	/^int label_index(PLA, word, varp, ip)$/
largest_string	set.c	501
last_col	sparse.h	36
last_col	sparse.h	70
last_fp	main.c	19
last_gasp	gasp.c	/^pcover last_gasp(F, D, R, cost)$/
last_part	espresso.h	470
last_row	sparse.h	51
last_row	sparse.h	67
last_word	espresso.h	473
length	sparse.h	33
length	sparse.h	48
level	unate.c	225
lex_order	setc.c	/^int lex_order(a, b)$/
lex_sort	cvrm.c	/^pcover lex_sort(T)$/
line_length_error	cvrin.c	8
lineno	cvrin.c	9
lower_bound	mincov_int.h	19
make_disjoint	sharp.c	/^pcover make_disjoint(A)$/
make_sparse	sparse.c	/^pcover make_sparse(F, D, R)$/
makeup_labels	cvrout.c	/^int makeup_labels(PLA)$/
map	map.c	/^void map(T)$/
map_cover_to_unate	unate.c	/^pcover map_cover_to_unate(T)$/
map_dcset	hack.c	/^map_dcset(PLA)$/
map_output_symbolic	hack.c	/^map_output_symbolic(PLA)$/
map_symbolic	hack.c	/^map_symbolic(PLA)$/
map_symbolic_cover	hack.c	/^pcover map_symbolic_cover(T, list, base)$/
map_unate_to_cover	unate.c	/^pcover map_unate_to_cover(A)$/
mapindex	map.c	37
mark_irredundant	irred.c	/^mark_irredundant(F, D)$/
massive_count	cofactor.c	/^void massive_count(T)$/
max_depth	mincov_int.h	11
max_print_depth	mincov_int.h	10
mem_usage	util_signature.c	/^mem_usage(name)$/
merge_list	black_white.c	/^merge_list()$/
mincov	expand.c	/^void mincov(BB, RAISE, FREESET)$/
mini_sort	cvrm.c	/^pcover mini_sort(F, compare)$/
minimize	opo.c	/^void minimize(PLA)$/
minimize_exact	exact.c	/^minimize_exact(F, D, R, exact_cover)$/
minimize_exact_literals	exact.c	/^minimize_exact_literals(F, D, R, exact_cover)$/
minimize_pair	pair.c	/^int minimize_pair(pair)$/
minterms	map.c	/^pset minterms(T)$/
most_frequent	expand.c	/^int most_frequent(CC, FREESET)$/
mv	espresso.h	261
mv_mask	espresso.h	475
mv_reduce	sparse.c	/^mv_reduce(F, D)$/
name	main.h	15
name	main.h	81
name	main.h	98
ncols	sparse.h	71
needs_dcset	main.h	19
needs_offset	main.h	18
new_PLA	cvrin.c	/^pPLA new_PLA()$/
new_cover	espresso.h	/^#define new_cover(i)            sf_new(i, cube.siz/
new_cube	espresso.h	/^#define new_cube()              set_new(cube.size)/
next	espresso.h	70
next	espresso.h	279
next	espresso.h	286
next	espresso.h	296
next_col	sparse.h	22
next_col	sparse.h	52
next_row	sparse.h	20
next_row	sparse.h	37
no_branching	mincov_int.h	18
nodes	mincov_int.h	12
nrows	sparse.h	68
num_binary_vars	espresso.h	468
num_mv_vars	espresso.h	483
num_plas	main.h	17
num_vars	espresso.h	467
opo	opo.c	/^pcover opo(phase, T, D, R, first_output)$/
opo_exact	opo.c	52
opo_leaf	opo.c	/^pset_family opo_leaf(T, select, out1, out2)$/
opo_no_make_sparse	opo.c	50
opo_recur	opo.c	/^pset_family opo_recur(T, D, select, offset, first,/
opo_repeated	opo.c	51
opoall	opo.c	/^void opoall(PLA, first_output, last_output, opo_st/
optarg	getopt.c	9
optind	getopt.c	10
option_table	main.h	20
out	espresso.h	260
output	espresso.h	484
output_phase_setup	opo.c	/^output_phase_setup(PLA, first_output)$/
output_symbolic_constraints	cvrout.c	/^output_symbolic_constraints(fp, PLA, output_symbol/
pPLA	espresso.h	310
pair	espresso.h	306
pair_all	pair.c	/^pair_all(PLA, pair_strategy)$/
pair_best_cost	pair.c	/^ppair pair_best_cost(cost_array_local)$/
pair_free	pair.c	/^int pair_free(pair)$/
pair_minim_strategy	pair.c	357
pair_new	pair.c	/^ppair pair_new(n)$/
pair_save	pair.c	/^ppair pair_save(pair, n)$/
pair_struct	espresso.h	268
pairvar	pair.c	/^pcover pairvar(A, pair)$/
parse_pla	cvrin.c	/^void parse_pla(fp, PLA)$/
part_size	espresso.h	471
part_zeros	espresso.h	488
parts_active	espresso.h	490
pbv1	set.c	/^char *pbv1(s, n)$/
pc1	cvrout.c	/^char *pc1(c) pcube c;$/
pc2	cvrout.c	/^char *pc2(c) pcube c;$/
pcost	espresso.h	264
pcover	espresso.h	250
pcube	espresso.h	247
phase	cvrm.c	393
phase	espresso.h	305
phase_assignment	opo.c	/^void phase_assignment(PLA, opo_strategy)$/
pla_type	espresso.h	304
pla_types	globals.c	30
pla_types_struct	espresso.h	451
pls_group	cvrout.c	/^void pls_group(PLA, fp)$/
pls_label	cvrout.c	/^void pls_label(PLA, fp)$/
pls_output	cvrout.c	/^void pls_output(PLA)$/
pop_black_list	black_white.c	/^pop_black_list()$/
pos	globals.c	18
pos	espresso.h	278
ppair	espresso.h	272
prev_col	sparse.h	23
prev_col	sparse.h	53
prev_row	sparse.h	21
prev_row	sparse.h	38
primes	espresso.h	263
primes_consensus	primes.c	/^pcover primes_consensus(T)$/
primes_consensus_merge	primes.c	/^primes_consensus_merge(Tl, Tr, cl, cr)$/
primes_consensus_special_cases	primes.c	/^primes_consensus_special_cases(T, Tnew)$/
print_bool	espresso.h	/^#define print_bool(x) ((x) == 0 ? "FALSE" : ((x) =/
print_bw	black_white.c	/^print_bw(size)$/
print_cost	cvrmisc.c	/^char *print_cost(F)$/
print_cover	util_signature.c	/^print_cover(F,name)$/
print_cube	cvrout.c	/^void print_cube(fp, c, out_map)$/
print_expanded_cube	cvrout.c	/^void print_expanded_cube(fp, c, phase)$/
print_links	black_white.c	/^print_links(size,list)$/
print_list	essentiality.c	/^print_list(n,x,name)$/
print_pair	pair.c	/^print_pair(pair)$/
print_solution	globals.c	19
print_stack	black_white.c	/^print_stack()$/
print_time	espresso.h	/^#define print_time(t)	util_print_time(t)$/
print_trace	cvrmisc.c	/^void print_trace(T, name, time)$/
print_variable_list	black_white.c	/^print_variable_list()$/
ps1	set.c	/^char *ps1(a)$/
pset	espresso.h	60
pset_family	espresso.h	71
ptime	espresso.h	/^#define ptime()		util_cpu_time()$/
push_black_list	black_white.c	/^push_black_list()$/
r_free_count	essentiality.c	29
r_free_list	essentiality.c	27
r_head	essentiality.c	30
random_order	cvrm.c	/^pcover random_order(F)$/
read_cube	cvrin.c	/^void read_cube(fp, PLA)$/
read_pla	cvrin.c	/^int read_pla(fp, needs_dcset, needs_offset, pla_ty/
read_symbolic	cvrin.c	/^int read_symbolic(fp, PLA, word, retval)$/
recompute_onset	globals.c	20
reduce	reduce.c	/^pcover reduce(F, D)$/
reduce_cube	reduce.c	/^pcube reduce_cube(FD, p)$/
reduce_gasp	gasp.c	/^static pcover reduce_gasp(F, D)$/
reduced_c_free_count	essentiality.c	33
reduced_c_free_list	essentiality.c	32
remove_essential	globals.c	21
repeated_phase_assignment	opo.c	/^void repeated_phase_assignment(PLA)$/
reset_black_list	black_white.c	/^reset_black_list()$/
restore_cube_struct	cubestr.c	/^void restore_cube_struct()$/
rm2_contain	contain.c	/^int rm2_contain(A1, B1)$/
rm2_equal	contain.c	/^int rm2_equal(A1, B1, E1, compare)$/
rm_contain	contain.c	/^int rm_contain(A1)$/
rm_equal	contain.c	/^int rm_equal(A1, compare)$/
rm_rev_contain	contain.c	/^int rm_rev_contain(A1)$/
row	mincov_int.h	26
row_num	sparse.h	18
row_num	sparse.h	32
rows	sparse.h	62
rows_size	sparse.h	63
runtime	main.c	/^runtime()$/
s1	set.c	502
s_runtime	util_signature.c	/^s_runtime(total)$/
s_totals	util_signature.c	/^s_totals(time,i)$/
save_cube_struct	cubestr.c	/^void save_cube_struct()$/
sccc	reduce.c	/^pcube sccc(T)$/
sccc_cube	reduce.c	/^pcube sccc_cube(result, p)$/
sccc_merge	reduce.c	/^pcube sccc_merge(left, right, cl, cr)$/
sccc_special_cases	reduce.c	/^bool sccc_special_cases(T, result)$/
scofactor	cofactor.c	/^pcube *scofactor(T, c, var)$/
select_column	mincov.c	/^select_column(A, weight, indep)$/
select_essential	mincov.c	/^select_essential(A, select, weight, bound)$/
select_feasible	expand.c	/^void select_feasible(BB, CC, RAISE, FREESET, SUPER/
set_adjcnt	set.c	/^set_adjcnt(a, count, weight)$/
set_and	set.c	/^pset set_and(r, a, b)$/
set_andp	set.c	/^bool set_andp(r, a, b)$/
set_clear	set.c	/^pset set_clear(r, size)$/
set_copy	set.c	/^pset set_copy(r, a)$/
set_diff	set.c	/^pset set_diff(r, a, b)$/
set_dist	set.c	/^int set_dist(a, b)$/
set_family	espresso.h	63
set_family_garbage	set.c	8
set_fill	set.c	/^pset set_fill(r, size)$/
set_free	espresso.h	/^#define set_free(r)	FREE(r)$/
set_full	espresso.h	/^#define set_full(size)	set_fill(ALLOC(unsigned int/
set_insert	espresso.h	/^#define set_insert(set, e)      (set[WHICH_WORD(e)/
set_merge	set.c	/^pset set_merge(r, a, b, mask)$/
set_new	espresso.h	/^#define set_new(size)	set_clear(ALLOC(unsigned int/
set_not	sigma.c	/^set_not(c)$/
set_or	set.c	/^pset set_or(r, a, b)$/
set_ord	set.c	/^int set_ord(a)$/
set_orp	set.c	/^bool set_orp(r, a, b)$/
set_pair	pair.c	/^void set_pair(PLA)$/
set_pair1	pair.c	/^void set_pair1(PLA, adjust_labels)$/
set_phase	opo.c	/^pPLA set_phase(PLA)$/
set_remove	espresso.h	/^#define set_remove(set, e)      (set[WHICH_WORD(e)/
set_save	espresso.h	/^#define set_save(r)	set_copy(ALLOC(unsigned int, S/
set_time_limit	util_signature.c	/^set_time_limit(seconds)$/
set_write	set.c	/^void set_write(fp, a)$/
set_xor	set.c	/^pset set_xor(r, a, b)$/
setdown_cube	cubestr.c	/^void setdown_cube()$/
setp_disjoint	set.c	/^bool setp_disjoint(a, b)$/
setp_empty	set.c	/^bool setp_empty(a)$/
setp_equal	set.c	/^bool setp_equal(a, b)$/
setp_full	set.c	/^bool setp_full(a, size)$/
setp_implies	set.c	/^bool setp_implies(a, b)$/
setup_BB_CC	expand.c	/^void setup_BB_CC(BB, CC)$/
setup_bw	black_white.c	/^setup_bw(R,c)$/
sf	unate.c	224
sf_active	set.c	/^pset_family sf_active(A)$/
sf_addcol	set.c	/^pset_family sf_addcol(A, firstcol, n)$/
sf_addset	set.c	/^pset_family sf_addset(A, s)$/
sf_and	set.c	/^pset sf_and(A)$/
sf_append	set.c	/^pset_family sf_append(A, B)$/
sf_bm_print	set.c	/^void sf_bm_print(A)$/
sf_bm_read	set.c	/^pset_family sf_bm_read(fp)$/
sf_cleanup	set.c	/^void sf_cleanup()$/
sf_compress	set.c	/^pset_family sf_compress(A, c)$/
sf_contain	contain.c	/^pset_family sf_contain(A)$/
sf_copy	set.c	/^pset_family sf_copy(R, A)$/
sf_copy_col	set.c	/^pset_family sf_copy_col(dst, dstcol, src, srccol)$/
sf_count	set.c	/^int *sf_count(A)$/
sf_count_restricted	set.c	/^int *sf_count_restricted(A, r)$/
sf_delc	set.c	/^pset_family sf_delc(A, first, last)$/
sf_delcol	set.c	/^pset_family sf_delcol(A, firstcol, n)$/
sf_delset	set.c	/^void sf_delset(A, i)$/
sf_dupl	contain.c	/^pset_family sf_dupl(A)$/
sf_equal	util_signature.c	/^sf_equal(F1,F2)$/
sf_free	set.c	/^void sf_free(A)$/
sf_inactive	set.c	/^pset_family sf_inactive(A)$/
sf_ind_contain	contain.c	/^pset_family sf_ind_contain(A, row_indices)$/
sf_ind_unlist	contain.c	/^pset_family sf_ind_unlist(A1, totcnt, size, row_in/
sf_join	set.c	/^pset_family sf_join(A, B)$/
sf_list	contain.c	/^pset *sf_list(A)$/
sf_merge	contain.c	/^pset_family sf_merge(A1, B1, E1, totcnt, size)$/
sf_new	set.c	/^pset_family sf_new(num, size)$/
sf_or	set.c	/^pset sf_or(A)$/
sf_permute	set.c	/^pset_family sf_permute(A, permute, npermute)$/
sf_print	set.c	/^void sf_print(A)$/
sf_read	set.c	/^pset_family sf_read(fp)$/
sf_rev_contain	contain.c	/^pset_family sf_rev_contain(A)$/
sf_save	set.c	/^pset_family sf_save(A)$/
sf_size	espresso.h	65
sf_sort	contain.c	/^pset *sf_sort(A, compare)$/
sf_transpose	set.c	/^pset_family sf_transpose(A)$/
sf_union	contain.c	/^pset_family sf_union(A, B)$/
sf_unlist	contain.c	/^pset_family sf_unlist(A1, totcnt, size)$/
sf_write	set.c	/^void sf_write(fp, A)$/
sharp	sharp.c	/^pcover sharp(a, b)$/
signature	signature.c	/^signature(F1, D1, R1)$/
signature_form_table	signature_exact.c	/^signature_form_table(ESCubes, ESSet)$/
signature_minimize_exact	signature_exact.c	/^signature_minimize_exact(ESCubes,ESSet)$/
simp_comp	compl.c	/^void simp_comp(T, Tnew, Tbar)$/
simp_comp_special_cases	compl.c	/^bool simp_comp_special_cases(T, Tnew, Tbar)$/
simplify	compl.c	/^pcover simplify(T)$/
simplify_cubelist	cofactor.c	/^simplify_cubelist(T)$/
simplify_special_cases	compl.c	/^bool simplify_special_cases(T, Tnew)$/
single_expand	globals.c	22
size	espresso.h	466
size_sort	cvrm.c	/^pcover size_sort(T)$/
size_stamp	cvrmisc.c	/^void size_stamp(T, name)$/
skip_line	cvrin.c	/^void skip_line(fpin, fpout, echo)$/
skip_make_sparse	globals.c	16
sm_alloc	matrix.c	/^sm_alloc()$/
sm_alloc_size	matrix.c	/^sm_alloc_size(row, col)$/
sm_block_partition	part.c	/^sm_block_partition(A, L, R)$/
sm_cleanup	matrix.c	/^sm_cleanup()$/
sm_col	sparse.h	10
sm_col_alloc	cols.c	/^sm_col_alloc()$/
sm_col_and	cols.c	/^sm_col_and(p1, p2)$/
sm_col_compare	cols.c	/^sm_col_compare(p1, p2)$/
sm_col_contains	cols.c	/^sm_col_contains(p1, p2)$/
sm_col_dominance	dominate.c	/^sm_col_dominance(A, weight)$/
sm_col_dup	cols.c	/^sm_col_dup(pcol)$/
sm_col_find	cols.c	/^sm_col_find(pcol, row)$/
sm_col_free	cols.c	/^sm_col_free(pcol)$/
sm_col_freelist	matrix.c	14
sm_col_hash	cols.c	/^sm_col_hash(pcol, modulus)$/
sm_col_insert	cols.c	/^sm_col_insert(pcol, row)$/
sm_col_intersects	cols.c	/^sm_col_intersects(p1, p2)$/
sm_col_print	cols.c	/^sm_col_print(fp, pcol)$/
sm_col_remove	cols.c	/^sm_col_remove(pcol, row)$/
sm_col_remove_element	cols.c	/^sm_col_remove_element(pcol, p)$/
sm_col_struct	sparse.h	46
sm_copy_col	matrix.c	/^sm_copy_col(dest, dest_col, pcol)$/
sm_copy_row	matrix.c	/^sm_copy_row(dest, dest_row, prow)$/
sm_delcol	matrix.c	/^sm_delcol(A, i)$/
sm_delrow	matrix.c	/^sm_delrow(A, i)$/
sm_dump	matrix.c	/^sm_dump(A, s, max)$/
sm_dup	matrix.c	/^sm_dup(A)$/
sm_element	sparse.h	8
sm_element_alloc	sparse_int.h	/^#define sm_element_alloc(newobj) \\$/
sm_element_alloc	sparse_int.h	/^#define sm_element_alloc(newobj)	\\$/
sm_element_free	sparse_int.h	/^#define sm_element_free(e) \\$/
sm_element_free	sparse_int.h	/^#define sm_element_free(e)		\\$/
sm_element_freelist	matrix.c	12
sm_element_struct	sparse.h	17
sm_find	matrix.c	/^sm_find(A, rownum, colnum)$/
sm_foreach_col	sparse.h	/^#define sm_foreach_col(A, pcol)	\\$/
sm_foreach_col_element	sparse.h	/^#define sm_foreach_col_element(pcol, p)	\\$/
sm_foreach_row	sparse.h	/^#define sm_foreach_row(A, prow)	\\$/
sm_foreach_row_element	sparse.h	/^#define sm_foreach_row_element(prow, p)	\\$/
sm_free	matrix.c	/^sm_free(A)$/
sm_get	sparse.h	/^#define sm_get(type, x) \\$/
sm_get_col	sparse.h	/^#define sm_get_col(A, colnum)	\\$/
sm_get_row	sparse.h	/^#define sm_get_row(A, rownum)	\\$/
sm_insert	matrix.c	/^sm_insert(A, row, col)$/
sm_longest_col	matrix.c	/^sm_longest_col(A)$/
sm_longest_row	matrix.c	/^sm_longest_row(A)$/
sm_matrix	sparse.h	11
sm_matrix_struct	sparse.h	61
sm_maximal_independent_set	indep.c	/^sm_maximal_independent_set(A, weight)$/
sm_mincov	mincov.c	/^sm_mincov(A, select, weight, lb, bound, depth, sta/
sm_minimum_cover	mincov.c	/^sm_minimum_cover(A, weight, heuristic, debug_level/
sm_num_elements	matrix.c	/^sm_num_elements(A)$/
sm_print	matrix.c	/^sm_print(fp, A)$/
sm_put	sparse.h	/^#define sm_put(x, val) \\$/
sm_read	matrix.c	/^sm_read(fp, A)$/
sm_read_compressed	matrix.c	/^sm_read_compressed(fp, A)$/
sm_remove	matrix.c	/^sm_remove(A, rownum, colnum)$/
sm_remove_element	matrix.c	/^sm_remove_element(A, p)$/
sm_resize	matrix.c	/^sm_resize(A, row, col)$/
sm_row	sparse.h	9
sm_row_alloc	rows.c	/^sm_row_alloc()$/
sm_row_and	rows.c	/^sm_row_and(p1, p2)$/
sm_row_compare	rows.c	/^sm_row_compare(p1, p2)$/
sm_row_contains	rows.c	/^sm_row_contains(p1, p2)$/
sm_row_dominance	dominate.c	/^sm_row_dominance(A)$/
sm_row_dup	rows.c	/^sm_row_dup(prow)$/
sm_row_find	rows.c	/^sm_row_find(prow, col)$/
sm_row_free	rows.c	/^sm_row_free(prow)$/
sm_row_freelist	matrix.c	13
sm_row_hash	rows.c	/^sm_row_hash(prow, modulus)$/
sm_row_insert	rows.c	/^sm_row_insert(prow, col)$/
sm_row_intersects	rows.c	/^sm_row_intersects(p1, p2)$/
sm_row_print	rows.c	/^sm_row_print(fp, prow)$/
sm_row_remove	rows.c	/^sm_row_remove(prow, col)$/
sm_row_remove_element	rows.c	/^sm_row_remove_element(prow, p)$/
sm_row_struct	sparse.h	31
sm_write	matrix.c	/^sm_write(fp, A)$/
so_both_do_espresso	cvrm.c	/^int so_both_do_espresso(PLA, i)$/
so_both_do_exact	cvrm.c	/^int so_both_do_exact(PLA, i)$/
so_both_espresso	cvrm.c	/^void so_both_espresso(PLA, strategy)$/
so_both_save	cvrm.c	/^int so_both_save(PLA, i)$/
so_do_espresso	cvrm.c	/^int so_do_espresso(PLA, i)$/
so_do_exact	cvrm.c	/^int so_do_exact(PLA, i)$/
so_espresso	cvrm.c	/^void so_espresso(PLA, strategy)$/
so_save	cvrm.c	/^int so_save(PLA, i)$/
solution_accept	solution.c	/^solution_accept(sol, A, weight, col)$/
solution_add	solution.c	/^solution_add(sol, weight, col)$/
solution_alloc	solution.c	/^solution_alloc()$/
solution_choose_best	solution.c	/^solution_choose_best(best1, best2)$/
solution_dup	solution.c	/^solution_dup(sol)$/
solution_free	solution.c	/^solution_free(sol)$/
solution_reject	solution.c	/^solution_reject(sol, A, weight, col)$/
solution_struct	mincov_int.h	25
solution_t	mincov_int.h	24
sort_reduce	cvrm.c	/^pcover sort_reduce(T)$/
sorted_insert	sparse_int.h	/^#define sorted_insert(type, first, last, count, ne/
sparse	espresso.h	482
split_list	black_white.c	/^split_list(R,v)$/
stack_head	black_white.c	29
stack_p	black_white.c	29
stack_tail	black_white.c	29
start_time	sharp.c	7
start_time	signature.c	18
start_time	mincov_int.h	17
stats_struct	mincov_int.h	8
stats_t	mincov_int.h	7
subcommands	main.c	/^subcommands()$/
summary	globals.c	23
super_gasp	gasp.c	/^pcover super_gasp(F, D, R, cost)$/
symbolic	espresso.h	308
symbolic_hack_labels	hack.c	/^symbolic_hack_labels(PLA, list, compress, new_size/
symbolic_label	espresso.h	294
symbolic_label_length	espresso.h	295
symbolic_label_struct	espresso.h	284
symbolic_label_t	espresso.h	287
symbolic_list	espresso.h	292
symbolic_list_length	espresso.h	293
symbolic_list_struct	espresso.h	276
symbolic_list_t	espresso.h	280
symbolic_output	espresso.h	309
symbolic_struct	espresso.h	291
symbolic_t	espresso.h	297
taut_special_cases	irred.c	/^taut_special_cases(T)$/
tautology	irred.c	/^tautology(T)$/
temp	espresso.h	477
temp_cdata_save	globals.c	56
temp_cube_save	globals.c	55
time_usage	util_signature.c	/^time_usage(name)$/
toggle	reduce.c	12
total	espresso.h	262
total_calls	globals.c	11
total_name	globals.c	9
total_time	globals.c	10
totals	cvrmisc.c	/^void totals(time, i, T, cost)$/
trace	globals.c	24
unate_compl	unate.c	/^pset_family unate_compl(A)$/
unate_complement	unate.c	/^pset_family unate_complement(A)$/
unate_count	essentiality.c	41
unate_intersect	unate.c	/^pset_family unate_intersect(A, B, largest_only)$/
unate_list	essentiality.c	40
uncof_output	cvrm.c	/^pcover uncof_output(T, i)$/
unravel	cvrm.c	/^pcover unravel(B, start)$/
unravel_range	cvrm.c	/^pcover unravel_range(B, start, end)$/
unwrap_onset	globals.c	25
usage	main.c	/^usage()$/
use_random_order	globals.c	26
use_super_gasp	globals.c	27
user_word	sparse.h	24
user_word	sparse.h	39
user_word	sparse.h	54
user_word	sparse.h	72
value	espresso.h	453
value	main.h	82
value	main.h	100
var1	espresso.h	270
var2	espresso.h	271
var_mask	espresso.h	476
var_zeros	espresso.h	489
variable	essentiality.c	36
variable	espresso.h	277
variable	main.h	99
variable_backward_chain	black_white.c	306
variable_count	black_white.c	304
variable_count	essentiality.c	49
variable_forward_chain	black_white.c	305
variable_head	black_white.c	307
variable_head	essentiality.c	50
variable_list_alloc	black_white.c	/^variable_list_alloc(size)$/
variable_list_delete	black_white.c	/^variable_list_delete(element)$/
variable_list_empty	black_white.c	/^variable_list_empty()$/
variable_list_init	black_white.c	/^variable_list_init(reduced_c_free_count, reduced_c/
variable_list_insert	black_white.c	/^variable_list_insert(element)$/
variable_order	essentiality.c	47
variable_tail	black_white.c	308
vars_active	espresso.h	492
vars_unate	espresso.h	493
verbose_debug	globals.c	8
verify	verify.c	/^bool verify(F, Fold, Dold)$/
verify_cover	mincov.c	/^verify_cover(A, cover)$/
verify_indep_set	indep.c	/^verify_indep_set(A, indep)$/
visit_col	part.c	/^visit_col(A, pcol, rows_visited, cols_visited)$/
visit_row	part.c	/^visit_row(A, prow, rows_visited, cols_visited)$/
void	espresso.h	16
white_head	black_white.c	24
white_tail	black_white.c	24
wsize	espresso.h	64
